[{"content":"Reference ","date":"2025-11-01T23:20:14+08:00","permalink":"https://cold-rivers-snow.github.io/p/05%E9%AB%98%E6%95%88%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%97%A5%E5%BF%97/","title":"05高效的多线程日志"},{"content":"思维方式转变两点：\n当前线程随时可能会被切换出去，或者被抢占。 多线程程序中事件的发生顺序不再有全局统一的先后关系。 基本线程原语的选用 Linux 平台 11 个最基本的 Pthreads 函数：\n2个：线程的创建和等待结束（join）。封装为 muduo::Thread 4个：mutex 的创建、销毁、加锁、解锁。封装为 muduo::MutexLock 5个：条件变量的创建、销毁、等待、通知、广播。封装为 muduo::Condition\n可以酌情使用的：\npthread_once. 封装为 muduo::Singleton 。其实不如直接用全局变量 pthread_key* ,封装为 muduo::ThreadLocal。可以考虑用 __thread 替换之。 不建议使用的：\npthread_rwlock， 读写锁通常应慎用。 sem_*, 避免使用信号量（semaphore）。它的功能与条件变量重合，但容易出错。 pthread_{cancel,kill}。程序出现他们，通常意味设计出了问题 C/C++ 系统库的线程安全性 对于标准而言，关键的不是定义线程库，而是规定内存模型（memory model）。特别是规定一个线程对某个共享变量的修改何时能被其他线程看到，这称为内存序（memory ordering）或者内存能见度（memory visibility）。\nC/C++ 标准库中绝大多数泛型算法是线程安全的。\nLinux 上的线程标识 pthread_t 不能作为线程标识，同一个进程先后不同的线程 pthread_t 可能相同\n建议使用 gettid(2) 系统调用的返回值作为线程 id。好处：\n类型 pid_t, 通常是小整数，便于日志输出。最大值是 /proc/sys/kernel/pid_max 默认 32768 直接标识内核的任务调度 id，因此 /proc 文件系统中可以找到对应项。 /proc/tid 或 /proc/pid/task/tid. 使用其他工具 top 等也能查看 任何时刻全局唯一。Linux 分配新 pid 采用递增轮回办法，短时间内启动的多个线程也会具有不同的线程 id 0 是非法值，因此操作系统的第一个进程 init 的 pid 是 1 线程数目可以从 /proc/pid/status 拿到\ngettid(2) 为系统调用，每次都系统调用比较浪费， muduo::CurrentThread::tid() 采用 __thread 变量缓存，只有在线程第一次调用的时候才会系统调用。以后直接从 thread local 缓存线程 id 拿结果（可参考 glib）。\nfork(2) 子进程看到 stale 缓存，通过 pthread_atfork() 注册一个回调，情况缓存id\n线程的创建与销毁守则 程序库不应该在未提取告知的情况下创建自己的 “背景线程” 尽量用相同的方式创建线程 进入 main 函数之前不应该启动线程 程序中线程的创建最好能在初始化阶段全部完成。 C++ 保证在进入 main() 函数之前完成全局对象（包括 namespace 级全局对象、文件级静态对象、class 的静态对象，但不包括函数内的静态对象）的构造\n线程的销毁方式：\n自然死亡：从线程主函数返回，线程正常退出。 非自然死亡：从线程主函数抛出异常或线程触发 segfault 信号等非法操作 自杀：在线程中调用 pthread_exit() 来立刻退出线程 他杀：其他线程调用 pthread_cancel() 来强制终止某个线程 pthread_cancel 与 C++ pthread_cancel 意思是线程执行到这里有可能被终止\n在 C++ 中，线程不是执行到此函数立刻终止，而是该函数抛出异常，这样可以有机会执行 stack unwind,析构栈上对象（特别是释放持有的锁）\nexie(3) 在 C++ 中不是线程安全的 exit(3) 函数在 C++ 中的作用除了终止进程，还会析构全局对象和已经构造完的函数静态对象，有潜在死锁可能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026#34;../Mutex.h\u0026#34; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; using namespace muduo; void someFunctionMayCallExit() { exit(1); } class GlobalObject { public: void doit() { MutexLockGuard lock(mutex_); someFunctionMayCallExit(); } ~GlobalObject() { printf(\u0026#34;GlobalObject:~GlobalObject\\n\u0026#34;); MutexLockGuard g(mutex_); // clean up printf(\u0026#34;GlobalObject:~GlobalObject cleanning\\n\u0026#34;); } private: MutexLock mutex_; }; GlobalObject g_obj; int main() { g_obj.doit(); } 如果必须退出，可以考虑 _exit(2) 系统调用，它不会试图析构全局对象，但是也不会执行其他任何清理工作。\n善用 __thread 关键字 __thread 是 gcc 内置的线程局部存储设施。\n__thread 只能用于修饰 POD 类型，不能修饰 class 类型，因为无法自动调用构造析构函数。\n__thread 可以用于修饰全局变量、函数内的静态变量，但是不能用于修饰函数的局部变量或者 class 的普通成员变量。\n__thread 变量的初始化只能用编译期常量。\n__thread 变量是每个线程有一份独立实体，各个线程的变量值互不干扰。还可以修饰那些 “值可能会变，带有全局性，但是又不值得用全局锁保护” 的变量。\n多线程与 IO 一个文件只由一个进程中的一个线程来读写，显然正确，多个线程操作同一块磁盘，在内核中也会排队。\n多线程遵守的原则：每个文件描述符只由一个线程操作，从而轻松解决消息收发的顺序性问题，也避免了关闭文件描述符的各种race condition。一个线程可以操作多个文件描述符，但一个线程不能操作别的线程拥有的文件描述符。\n对于磁盘文件，必要的时候多个线程可以同时调用 pread(2)/pwrite(2) 来读写同一个文件；对于 UDP,由于协议本身保证消息的原子性，在适当的条件下（比如消息之间彼此独立）可以多个线程同时读写同一个 UDP 文件描述符。\n用 RAII 包装文件描述符 Linux 的文件描述符是小整数，程序刚刚启动的时候，0 是标准输入，1 是标准输出，2 是标准错误。这时新打开的文件描述符会是 3，因为 POSIX 标准要求每次打开文件（含 socket）的时候必须使用当前最小科研的文件描述符号码。\nRAII，用 Socket 对象包装文件描述符，所有对此文件的描述符的读写操作都通过此对象进行，在对象的析构函数中关闭文件描述符。这样，只要 Socket 对象活着，就不会有其他 Socket 对象跟它一样的文件描述符。\n为什么服务端程序不应该关闭标准输出和标准错误？因为第三方库在特殊紧急情况下会往 stdout 或 stderr 打印出错信息，如果我没程序关闭了标准输出和标准错误，这两个文件描述符有可能被网络连接占用，结果造成对方收到莫名奇妙的数据。正确做法是把 stdout 或 stderr 重定向到磁盘文件（最好不要 /dev/null），这样不至于丢失关键信息。当然这些应该由启动服务程序的看门狗进程完成（参考 http://github.com/chenshuo/muduo-protorpc 的 Zurg slave 示例）。对服务程序本身是透明的。\nRAII 与 fork() 1 2 3 4 5 int main() { Foo foo; fork(); foo.doit() } 如果 Foo class 封装了某个资源，而这个资源没有被子进程继承，doit() 后子进程中错乱的。\nfork() 后，子进程继承父进程的几乎全部状态，但是有些例外。子进程会继承地址空间和文件描述符，因此管理动态内存和文件描述符用 RAII 即可。但是子进程不会继承：\n父进程的内存锁，mlock(2)、mlockall(2) 父进程的文件锁，fcntl(2) 父进程的某些定时器， settimer(2)、alarm(2)、timer_create(2)\u0026hellip; 见 man 2 fork 多线程与 fork() linux 的 fork() 只能克隆当前线程的 thread of control,不能克隆其他线程。 fork() 之后，除了当前线程外，其他线程都消失了。也就是说不能一下子 fork() 出一个和父进程一样的多线程子进程。\nfork() 之后，子进程不能调用：\nmalloc(3)。因为 malloc() 在访问全局状态时几乎肯定会加锁。 任何可能分配或释放内存的函数，包括 new、map::insert()、snprintf\u0026hellip;. 任何 Pthreads 函数。 不能用 pthread_cond_singal() 去通知父进程，只能通过读些 pipe(2) 来同步(http://github.com/chensuo/muduo-protorpc 中 Zurg slave 示例的Process::start()) printf() 系列函数，因为其他线程可能恰好持有 stdout/stderr 的锁。 除了 man 7 signal 中明确列出的 \u0026ldquo;signal 安全\u0026rdquo; 函数之外的任何函数 唯一安全的做法：fork() 之后立即调用 exec() 执行另一个程序。彻底隔断父子进程的联系。\n多线程与 signal 多线程程序中，使用 signal 第一原则时不使用 signal。\n不要用 signal 作为 IPC 手段。包括不要用 SIGUSR1 等信号来触发服务端的行为。如果需要参考 9.5 增加监听端口方式来实现双向的、可远程访问的进程控制 不要使用基于 signal 实现的定时函数，包括 alarm/ualarm/settimer/timer_create、sleep/usleep 。。。 不主动处理各种异常信号（SIGTERM、SIGINT。。）只用默认语义结束进程。 没有其他方法时，把异步信号改成同步的文件描述符。现代Linux 做法采用 signalfd(2) 把信号之间转换为文件描述符事件，从根本上避免使用 signal handler.(http://github.com/chenshuo/muduo-protorpc 中 Zurg slave 示例的 ChildManager class) Reference 《Time,Clocks and the Ordering of Events in a Distributed System》 http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf\n《Threads Cannot be Implemented as a Library》 http://www.hpl.hp.com/techreports/2004/HPL-2004-209.pdf\nhttp://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_09\n自调整数据结构，只读也会不安全 http://www.cs.au.dk/~gerth/aa11/slides/selfadjusting.pdf\nhttp://blog.csdn.net/program_think/article/details/3991107\nhttp://www.cppblog.com/lymons/archive/2008/12/19/69810.html\nhttp://www.cppblog.com/lymons/archive/2008/12/25/70227.html\nhttp://www.boost.org/doc/libs/1_34_0/doc/html/thread/faq.html\nhttp://stackoverflow.com/questions/433989/posix-cancellation-points\nhttp://pubs.opengroup.org/onlinepubs/000095399/functions/xsh_chap02_09.html#tag_02_09_05_02\nCancellation and C++ Exceptions http://udrepper.livejournal.com/21541.html\n《ELF Handing For Thread-Local Storage》 http://www.akkadia.org/drepper/tls.pdf\n__thread 使用规则 http://gcc.gnu.org/onlinedocs/gcc/Thread_002dLocal.html\nhttp://chenshuo.com/book/errata.html\nhttp://www.linuxprogrammingblog.com/threads-and-fork-think-twice-before-using-them\nhttp://www.cppblog.com/lymons/archive/2008/06/01/51836.html\nhttp://www.linuxprogrammingblog.com/all-about-linux-signals?page=11\nhttp://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04_03\nhttp://en.wikipedia.org/wiki/lnterrupt_handler\nhttp://www.gnu.org/software/libc/manual/html_mono/libc.html#Atomic-Data-Access\nhttp://www.cppblog.com/lymons/archive/2008/06/01/51838.html 和 51837.html\nLinux 新增系统调用启示 http://blog.csdn.net/solstice/article/details/5327881\n《Secure File Descriptor Handling》 http://udrepper.livejournal.com/20407.html\n","date":"2025-10-31T21:28:14+08:00","permalink":"https://cold-rivers-snow.github.io/p/04c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E7%B2%BE%E8%A6%81/","title":"04C++多线程系统编程精要"},{"content":"进程与线程 进程是操作系统里最重要的两个概念之一（另一个是文件）。粗略为内存中正常运行的程序，在 linux 端是通过 fork() 系统调用出来的东西，windows 下用 CreateProcess() 的产物。\n进程独立的地址空间，线程共享地址空间。\n单线程服务器常用编程模型 non-blocking IO + IO multiplexing 即 Reactor 模型。如下框架：\nlighttpd，单线程服务器。（与 Nginx 类似，每个工作进程又一个 event loop） libevent，libev。 ACE，Poo C++ libraries。 Java NIO，包括 Apache Mina 和 Netty POE (Perl) Twisted (Python) Boost.Asio 和 Windows I/O Completion Ports 实现了 Proactor 模型。ACE 也实现了Proactor 模型。\n多线程服务器常用编程模型 每个请求创建一个线程，使用阻塞 IO 操作。可伸缩性不佳。 使用线程池，同样使用阻塞 IO 操作，与 1 比，提高性能的措施。 使用 non-blocking-IO + IO multiplexing 。即 Java NIO 方式 Leader/Follower 等高级模式 one loop per thread 程序中每个 IO 线程有一个 event loop (或叫 Reactor)。 用于处理读写或定时事件。\n好处：\n线程数据基本固定，可在程序启动时设置，不会频繁创建和销毁。 可以方便的在线程间调配负载。 IO 事件发生的线程是固定的，同一个 TCP 连接不必考虑事件并发 线程池 muduo 中 ThreadPool，BlockingQueue, BoundedBlockingQueue\nBlockingQueue 可参考 java.util.concurrent 中的 (Array|Linked) BlockingQueue，使用基本数据结构和一个 mutex 2个 condition variables\nIntel Threading Building Blocks 里的 concurrent_queue\n推荐模式 one loop per thread + threadpool\nevent loop (也叫 IO loop) 用作 IO multiplexing 。 配合 non-blocking IO 和定时器 thread pool 用来作计算，具体可以是任务队列或生产者消费者队列 进程间通信只用 TCP 进程间通信首先 Sockets ，可跨主机，具有伸缩性。\ntcpdump + WireShark 分析网络利器，可编写自动化回归测试，也可用 tcpcopy 之类工具进行压力测试\n数据格式推荐 Google Protocol Buffers\nTCP 长连接好处：\n容易定位分布式系统中的服务之间的依赖关系。netstat -tpna | grep :port 可以找到服务的客户端地址。在客户端使用 netstat 或 lsof 查看哪个进程发起的连接。 通过接收和发送队列长度也容易定位网络或程序故障。netstat 的 Recv-Q 或 Send-Q 正常在 0 上下波动或为 0，如果 Recv-Q 不变或增加可能发生死锁或阻塞。如果 Send-Q 不变或增加，可能服务器太忙，来不及处理，也可能中间网络路由器故障，丢包，甚至对方服务器掉线。 多线程服务器的适用场合 服务端网络处理并发连接两种方式：\n当“线程”很廉价时，一台机器上可以创建远高于 CPU 数目的“线程”。这时一个线程只处理一个 TCP 连接（甚至半个），通常使用阻塞 IO (至少看起来如此)。例如：Python gevent、Go goroutine、Erlang actor。这里的“线程”由语言的 runtime 自行调度，与操作系统线程不是一回事。 当线程很宝贵时，一台机器上只能创建与 CPU 数目相当的线程。这时一个线程要处理多个 TCP 连接上的 IO，通常使用非阻塞 IO 和 IO multiplexing。例如：libevent、muduo、Netty。这是原生线程，能被操作系统的任务调度看见。 model：\n运行一个单线程的进程 运行一个多线程的进程 运行多个单线程的进程 运行多个多线程的进程 模式1是不可伸缩的，不能发挥多核的能力。 模式3是目前公认的主流模式。有以下两种子模式： 简单的把模式1的进程运行多份 主进程 +worker 进程，如果必须绑定到一个 TCP port ，比如 httpd + fastcgi 必须用单线程的场合 程序可能会 fork(2) 限制程序的 CPU 占有率 一个 fork(2) 之后一般有两种行为：\n立刻执行 exec(), 变身为另一个程序。例如：shell 和 inetd。又比如 lighttpd fork() 出子进程，然后运行 fastcgi 程序。或者集群中运行再计算节点上的负责启动 job 的守护进程（即“看门狗进程\u0026quot;） 不调用 exec(), 继续执行当前程序。 以上只有看门狗进程必须坚持单线程，其他均可替换为多线程程序（功能上）。\n单线程程序的优缺点 优势：简单。\nEvent loop 明显缺点，非抢占。\n多线程有优势吗？\nIO bound 或 CPU bound 服务没有优势。用很少的 CPU 负载就能让 IO 跑满或用很少的 IO 流量就能让 CPU跑满，多线程没啥用。 对于静态 web 页面，或者 ftp 服务器。cpu 负载很轻，主要瓶颈在磁盘 io 和网络 io 方面。这个使用用模式1 一个单线程程序就能撑满 io。用多线程并不能提高吞吐量，因为硬件容量已经饱和。同理增加 CPU 也不能提高吞吐量。 适用多线程程序的场景 提高响应速度，让 IO 和 “计算”相互重叠，降低 latency。虽然多线不能提高绝对性能，但是能提高平均响应性能。\n一个程序做成多线程，大致满足：\n有多个 cpu 可用。 线程间有共享数据，即内存中全局状态。如果没有共享数据用模式中主进程 +worker 进程。 共享数据是可修改的，而不是静态的常量表。如果数据不能修改可以用进程间 shared memory。模式3即可。 提供非均质的服务。即事件的响应有优先级差异，用专门的线程处理优先级高的事件。防止优先级反转。 latency 和 throughput 同样重要。不是简单的 io bound 和 cpu bound。程序有相当的计算量。 利用异步操作。比如 logging，无法 log file 还是 log server，都不应该阻塞 critical path（关键路径） 能 scale up。 具有可预测的性能。随负载增加，性能缓慢下降，超过一个值后会急速下降。线程数目一般不随负载变化。 多线程能有效的划分责任和功能，让每个线程的逻辑比较简单，任务单一，便于编码。而不是所有的逻辑塞到一个 event loop 里，不同类别的事件之间相互影响。 线程分类 IO 线程。这类线程主循环的 IO multiplexing。阻塞的等待在 select/poll/epoll_wait 系统调用上。功能不止 IO，简单的计算也可以放入其中，比如消息的编码和解码 计算线程。这类线程主要循环是 blocking queue，阻塞的等待在 condition variable上。这类线程一般位于 thread pool 中。不涉及 IO，一般避免任何阻塞操作。 第三方库所用的线程。比如 logging。又比如 database connection Linux 能启动多少个线程 对于 32bit linux，一个进程地址空间 4G，其用户态能访问 3GB 左右，一个线程默认栈大小10MB，一个继承大约启动 300 多个线程。如果不改调用栈大小，300左右是上限，程序的其他部分（数据段、代码段、堆、动态库等）同样要占用内存。\n对于 64bit linux 线程数目大大增加，：64 位系统的虚拟地址空间理论上为 2⁶⁴ 字节（远超物理内存），但线程栈的虚拟地址分配会占用连续地址空间，极端情况下可能因地址碎片导致无法分配新栈（即使内存充足）。 不考虑内核对线程限制。（16GB 内存）：若线程栈设为默认 8MB，且其他资源充足，实际可启动约 1000~2000 个线程（受限于物理内存）。\n多线程能提高并发度吗 并发连接数 不能\nthread per connection 不适合高并发场合，其 scalability 不佳。one loop per thread 的并发度足够大，其与 cpu 数目成正比。\n维度 thread-per-connection one-loop-per-thread 线程数与连接数关系 1:1（连接多则线程多） 1:N（一个线程处理多个连接） 线程数与 CPU 关系 无关（可能远多于 CPU 核心） 成正比（通常等于 CPU 核心数） 资源开销 高（线程栈 + 调度成本） 低（固定线程 + 事件驱动） 并发上限 低（受限于线程数和内存） 高（受限于 IO 多路复用能力） 适用场景 低并发、短连接（如内部服务） 高并发、长连接（如 Web 服务器） 多线程能提高吞吐量吗 对于计算密集型服务，不能\n多线程能降低响应时间吗 设计合理，充分利用多核 可以\n多线程程序如何让 IO 和 “计算” 相互重叠，降低 latency 基本思路：把 IO 操作（通常是写操作）通过 BlockingQueue 交给别的线程去做，自己不必等待。\n为什么第三方库往往用自己的线程 第三方库不一定能很好的适用并融入这个 event loop framework，有时需要用线程来做一些的串并转换。\n什么是线程池大小的阻抗匹配原则 T 线程数 * P 每个线程占用 cpu 的时间 = C 占用 cpu 的个数\nC = 8 T = 1.0 那么 T = 8 正好跑满 cpu\nC = 8 T = 0.5 那么 T = 16 跑满 cpu 50% 的线程能让 cpu 繁忙，启动再多只会增加上下文的切换开销而降低性能，并不能再提高吞吐量\n除了 Ractor 模型，其他的 non-trivial 模型 Proactor，如果一次请求响应中要和别的进程打多次交道，那么 Proactor 模型能做到更高的并发度。代价是，代码变得支离破碎，难以理解。\n一个多线程得进程和多个相同得单线程进程的模型如何选择 工作集指服务程序响应一次请求访问的内存大小。\n根据工作集做取舍，访问内存大，则用多线程，可以进程内共享数据。访问内存小，可以用单线程的多个进程，享受编程的简单性。\nReference 《Erlang 程序设计》\nhttp://www.cs.wustl.edu/~schmidt/PDF/proactor.pdf\nhttp://www.cs.wustl.edu/~schmidt/PDF/Reactor1-93.pdf，Reactor2-93.pdf，Reactor.pdf\nhttp://www.kegel.com/c10k.html\nhttp://www.cs.uwaterloo.ca/~brecht/pubs.html\nhttp://hal.inria.fr/docs/00/67/44/75/PDF/paper.pdf\nhttp://pod.tst.eu/http://cvs.schmorp.de/libdev/ev.pod#THREADS_AND_COROUTINES\nhttp://blog.csdn.net/haoel/article/details/2224055\nhttp://code.google.com/p/tcpcopy/\nhttp://kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html\nhttp://blog.codingnow.com/2006/04/iocp_kqueue_epoll.html\nhttps://computing.llnl.gov/linux/slurm\nhttp://www.slideshare.net/chenshuo/zurg-part-1\nhttp://blog.csdn.net/Solstice/article/details/5334243\nhttp://www.cs.berkeley.edu/~culler/papers/events.pdf\nhttp://blog.csdn.net/Solstice/article/details/2096209\nhttps://github.com/chaoslawful/drizzle-nginx-module\nhttp://jscex.info/zh-cn/\n","date":"2025-10-29T22:04:14+08:00","permalink":"https://cold-rivers-snow.github.io/p/03%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E5%9C%BA%E5%90%88%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9E%8B/","title":"03多线程服务器使用场合与常用模型"},{"content":"双向链表，删除 prev 则为单链表。\n1 2 3 4 5 6 7 8 9 10 11 12 template \u0026lt;typename E\u0026gt; class Node { public: E val; Node* next; Node* prev; Node(Node* prev, E element, Node* next) { this-\u0026gt;val = element; this-\u0026gt;next = next; this-\u0026gt;prev = prev; } }; 链表的元素可以分散在内存空间的天涯海角，通过每个节点上的 next, prev 指针，将零散的内存块串联起来形成一个链式结构。\n好处：\n提高内存利用率；只要 new 出来就能用 没有容量限制；用的时候就连接上，不用就断开 局限性：数组最大的优势是支持通过索引快速访问元素，链表没有\n同时持有头尾节点的引用 提高尾部插入的时间复杂度 虚拟头尾节点 虚拟节点是你内部实现数据结构的技巧，对外是不可见的 内存泄漏 delete 指针 ，并置为空 单链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stdexcept\u0026gt; template \u0026lt;typename T\u0026gt; class SingleLinkedList { private: // 节点结构 struct Node { T val; Node* next; Node() = default; Node(T value) : val(value), next(nullptr) {} }; Node* head; Node* tail; int size_; public: SingleLinkedList() { head = new Node(T()); tail = head; size_ = 0; } ~SingleLinkedList() { Node* current = head; while (current != nullptr) { Node* next = current-\u0026gt;next; delete current; current = nullptr; current = next; } } void addFirst(T e) { Node* newNode = new Node(e); newNode-\u0026gt;next = head-\u0026gt;next; head-\u0026gt;next = newNode; if (size_ == 0) { tail = newNode; } size_++; } void addLast(T e) { Node* newNode = new Node(e); tail-\u0026gt;next = newNode; tail = newNode; size_++; } void add(int index, T element) { checkPositionIndex(index); if (index == size_) { addLast(element); return; } Node* prev = head; for (int i = 0; i \u0026lt; index; i++) { prev = prev-\u0026gt;next; } Node* newNode = new Node(element); newNode-\u0026gt;next = prev-\u0026gt;next; prev-\u0026gt;next = newNode; size_++; } T removeFirst() { if (isEmpty()) { throw std::out_of_range(\u0026#34;No elements to remove\u0026#34;); } Node* first = head-\u0026gt;next; head-\u0026gt;next = first-\u0026gt;next; if (size_ == 1) { tail = head; } size_--; T val = first-\u0026gt;val; delete first; first = nullptr; return val; } T removeLast() { if (isEmpty()) { throw std::out_of_range(\u0026#34;No elements to remove\u0026#34;); } Node* prev = head; while (prev-\u0026gt;next != tail) { prev = prev-\u0026gt;next; } T val = tail-\u0026gt;val; delete tail; prev-\u0026gt;next = nullptr; tail = prev; size_--; return val; } T remove(int index) { checkElementIndex(index); Node* prev = head; for (int i = 0; i \u0026lt; index; i++) { prev = prev-\u0026gt;next; } Node* nodeToRemove = prev-\u0026gt;next; prev-\u0026gt;next = nodeToRemove-\u0026gt;next; // 删除的是最后一个元素 if (index == size_ - 1) { tail = prev; } size_--; T val = nodeToRemove-\u0026gt;val; delete nodeToRemove; nodeToRemove = nullptr; return val; } // ***** 查 ***** T getFirst() { if (isEmpty()) { throw std::out_of_range(\u0026#34;No elements in the list\u0026#34;); } return head-\u0026gt;next-\u0026gt;val; } T getLast() { if (isEmpty()) { throw std::out_of_range(\u0026#34;No elements in the list\u0026#34;); } return tail-\u0026gt;val; } T get(int index) { checkElementIndex(index); Node* p = getNode(index); return p-\u0026gt;val; } // ***** 改 ***** T set(int index, T element) { checkElementIndex(index); Node* p = getNode(index); T oldVal = p-\u0026gt;val; p-\u0026gt;val = element; return oldVal; } // ***** 其他工具函数 ***** int size() { return size_; } bool isEmpty() { return size_ == 0; } private: bool isElementIndex(int index) { return index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; size_; } bool isPositionIndex(int index) { return index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt;= size_; } // 检查 index 索引位置是否可以存在元素 void checkElementIndex(int index) { if (!isElementIndex(index)) { throw std::out_of_range(\u0026#34;Index: \u0026#34; + std::to_string(index) + \u0026#34;, size_: \u0026#34; + std::to_string(size_)); } } // 检查 index 索引位置是否可以添加元素 void checkPositionIndex(int index) { if (!isPositionIndex(index)) { throw std::out_of_range(\u0026#34;Index: \u0026#34; + std::to_string(index) + \u0026#34;, size_: \u0026#34; + std::to_string(size_)); } } // 返回 index 对应的 Node // 注意：请保证传入的 index 是合法的 Node* getNode(int index) { Node* p = head-\u0026gt;next; for (int i = 0; i \u0026lt; index; i++) { p = p-\u0026gt;next; } return p; } }; int main() { SingleLinkedList\u0026lt;int\u0026gt; list; list.addFirst(1); list.addFirst(2); list.addLast(3); list.addLast(4); list.add(2, 5); std::cout \u0026lt;\u0026lt; list.removeFirst() \u0026lt;\u0026lt; std::endl; // 2 std::cout \u0026lt;\u0026lt; list.removeLast() \u0026lt;\u0026lt; std::endl; // 4 std::cout \u0026lt;\u0026lt; list.remove(1) \u0026lt;\u0026lt; std::endl; // 5 std::cout \u0026lt;\u0026lt; list.getFirst() \u0026lt;\u0026lt; std::endl; // 1 std::cout \u0026lt;\u0026lt; list.getLast() \u0026lt;\u0026lt; std::endl; // 3 std::cout \u0026lt;\u0026lt; list.get(1) \u0026lt;\u0026lt; std::endl; // 3 return 0; } 双链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stdexcept\u0026gt; template\u0026lt;typename T\u0026gt; class DoubleLinkedList { // 虚拟头尾节点 struct Node { T val; Node* next; Node* prev; Node() = default; Node(T value) : val(value), next(nullptr), prev(nullptr) {} }; Node* head; Node* tail; int size; public: // 构造函数初始化虚拟头尾节点 DoubleLinkedList() { head = new Node(T()); tail = new Node(T()); head-\u0026gt;next = tail; tail-\u0026gt;prev = head; size = 0; } ~DoubleLinkedList() { while (size \u0026gt; 0) { removeFirst(); } delete head; head = nullptr; delete tail; tail = nullptr; } // ***** 增 ***** void addLast(T e) { Node* x = new Node(e); Node* temp = tail-\u0026gt;prev; temp-\u0026gt;next = x; x-\u0026gt;prev = temp; // temp \u0026lt;-\u0026gt; x x-\u0026gt;next = tail; tail-\u0026gt;prev = x; // temp \u0026lt;-\u0026gt; x \u0026lt;-\u0026gt; tail size++; } void addFirst(T e) { Node* x = new Node(e); Node* temp = head-\u0026gt;next; // head \u0026lt;-\u0026gt; temp temp-\u0026gt;prev = x; x-\u0026gt;next = temp; head-\u0026gt;next = x; x-\u0026gt;prev = head; // head \u0026lt;-\u0026gt; x \u0026lt;-\u0026gt; temp size++; } void add(int index, T element) { checkPositionIndex(index); if (index == size) { addLast(element); return; } // 找到 index 对应的 Node Node* p = getNode(index); Node* temp = p-\u0026gt;prev; // temp \u0026lt;-\u0026gt; p // 新要插入的 Node Node* x = new Node(element); p-\u0026gt;prev = x; temp-\u0026gt;next = x; x-\u0026gt;prev = temp; x-\u0026gt;next = p; // temp \u0026lt;-\u0026gt; x \u0026lt;-\u0026gt; p size++; } // ***** 删 ***** T removeFirst() { if (size \u0026lt; 1) { throw std::out_of_range(\u0026#34;No elements to remove\u0026#34;); } // 虚拟节点的存在是我们不用考虑空指针的问题 Node* x = head-\u0026gt;next; Node* temp = x-\u0026gt;next; // head \u0026lt;-\u0026gt; x \u0026lt;-\u0026gt; temp head-\u0026gt;next = temp; temp-\u0026gt;prev = head; T val = x-\u0026gt;val; delete x; // head \u0026lt;-\u0026gt; temp size--; return val; } T removeLast() { if (size \u0026lt; 1) { throw std::out_of_range(\u0026#34;No elements to remove\u0026#34;); } Node* x = tail-\u0026gt;prev; Node* temp = tail-\u0026gt;prev-\u0026gt;prev; // temp \u0026lt;-\u0026gt; x \u0026lt;-\u0026gt; tail tail-\u0026gt;prev = temp; temp-\u0026gt;next = tail; T val = x-\u0026gt;val; x-\u0026gt;prev = nullptr; x-\u0026gt;next = nullptr; delete x; // temp \u0026lt;-\u0026gt; tail size--; return val; } T remove(int index) { checkElementIndex(index); // 找到 index 对应的 Node Node* x = getNode(index); Node* prev = x-\u0026gt;prev; Node* next = x-\u0026gt;next; // prev \u0026lt;-\u0026gt; x \u0026lt;-\u0026gt; next prev-\u0026gt;next = next; next-\u0026gt;prev = prev; T val = x-\u0026gt;val; x-\u0026gt;prev = nullptr; x-\u0026gt;next = nullptr; delete x; // prev \u0026lt;-\u0026gt; next size--; return val; } // ***** 查 ***** T get(int index) { checkElementIndex(index); // 找到 index 对应的 Node Node* p = getNode(index); return p-\u0026gt;val; } T getFirst() { if (size \u0026lt; 1) { throw std::out_of_range(\u0026#34;No elements in the list\u0026#34;); } return head-\u0026gt;next-\u0026gt;val; } T getLast() { if (size \u0026lt; 1) { throw std::out_of_range(\u0026#34;No elements in the list\u0026#34;); } return tail-\u0026gt;prev-\u0026gt;val; } // ***** 改 ***** T set(int index, T val) { checkElementIndex(index); // 找到 index 对应的 Node Node* p = getNode(index); T oldVal = p-\u0026gt;val; p-\u0026gt;val = val; return oldVal; } // ***** 其他工具函数 ***** int getSize() const { return size; } bool isEmpty() const { return size == 0; } void display() { std::cout \u0026lt;\u0026lt; \u0026#34;size = \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; std::endl; for (Node* p = head-\u0026gt;next; p != tail; p = p-\u0026gt;next) { std::cout \u0026lt;\u0026lt; p-\u0026gt;val \u0026lt;\u0026lt; \u0026#34; \u0026lt;-\u0026gt; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#34;nullptr\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::endl; } private: Node* getNode(int index) { checkElementIndex(index); Node* p = head-\u0026gt;next; // TODO: 可以优化，通过 index 判断从 head 还是 tail 开始遍历 for (int i = 0; i \u0026lt; index; i++) { p = p-\u0026gt;next; } return p; } bool isElementIndex(int index) const { return index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; size; } bool isPositionIndex(int index) const { return index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt;= size; } // 检查 index 索引位置是否可以存在元素 void checkElementIndex(int index) const { if (!isElementIndex(index)) throw std::out_of_range(\u0026#34;Index: \u0026#34; + std::to_string(index) + \u0026#34;, Size: \u0026#34; + std::to_string(size)); } // 检查 index 索引位置是否可以添加元素 void checkPositionIndex(int index) const { if (!isPositionIndex(index)) throw std::out_of_range(\u0026#34;Index: \u0026#34; + std::to_string(index) + \u0026#34;, Size: \u0026#34; + std::to_string(size)); } }; int main() { DoubleLinkedList\u0026lt;int\u0026gt; list; list.addLast(1); list.addLast(2); list.addLast(3); list.addFirst(0); list.add(2, 100); list.display(); // size = 5 // 0 \u0026lt;-\u0026gt; 1 \u0026lt;-\u0026gt; 100 \u0026lt;-\u0026gt; 2 \u0026lt;-\u0026gt; 3 \u0026lt;-\u0026gt; null return 0; } Reference https://labuladong.online/algo/data-structure-basic/linkedlist-basic/\n","date":"2025-10-28T10:04:14+08:00","permalink":"https://cold-rivers-snow.github.io/p/%E9%93%BE%E8%A1%A8%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/","title":"链表（链式存储）"},{"content":"算法对数据的操作就是增删改查（CURD） 时间复杂度：估算的是最坏的情况；是算法的执行效率，通常我们要去依靠循环次数和嵌套次数 空间复杂度：使用的变量开辟的空间的情况（说白了，我们只关注我们在堆栈上新创建了哪些变量，不需要关注函数输入的变量）；是算法的内存消耗，通常我们要去依靠算法开辟的空间和数据结构\n静态数组 类似于\n1 int arr[5] 数组名 arr 是一个指针的首地址，开辟了一段 5 * sizeof(int) 长度这么大的地址，用于存储数据。一旦开辟了就不能顺序扩容，必现开辟一段更长的地址，通过数据搬迁的方式增加数据。\n增： 空间有空余的情况下 在末尾增加，时间复杂度为 O(1) 在中间（非末尾）增加，时间复杂度为 O(n) 空间无空余的情况下（需要搬迁数据） 在末尾增加，时间复杂度为 O(n) 在中间（非末尾）增加，时间复杂度为 O(n) 删： 在末尾删除，时间复杂度为 O(1) 在中间（非末尾）删除，时间复杂度为 O(n)，需要搬迁数据 查：给定指定索引，查询索引对应的元素的值，时间复杂度 O(1)O(1)。 改：给定指定索引，修改索引对应的元素的值，时间复杂度 O(1)O(1)。 动态数组 动态数组底层还是静态数组，只是自动帮我们进行数组空间的扩缩容，并把增删查改操作进行了封装，让我们使用起来更方便而已。 c++中就是 vector\n自动扩缩容 索引越界的检查 删除元素谨防内存泄漏 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;stdexcept\u0026gt; template\u0026lt;typename T\u0026gt; struct Array { public: using iterator = T*; using const_iterator = const T*; Array() : _size(0), _cap(1) { _data = new T[_cap]; } explicit Array(size_t cap) : _size(0), _cap(cap) { if (cap \u0026lt; 1) { throw std::invalid_argument(\u0026#34;Capacity must greate zero\u0026#34;); } _data = new T[_cap]; } Array(const Array\u0026amp; other) : _size(other._size), _cap(other._cap) { _data = new T[_cap]; for (size_t i = 0; i \u0026lt; other.size(); i++) { _data[i] = other._data[i]; } } Array operator=(const Array\u0026amp; other) { if (this != \u0026amp;other) { delete []_data; _size = other._size; _cap = other._cap; _data = new T[other._data]; for (size_t i = 0; i \u0026lt; _size; i++) { _data[i] = other._data[i]; } } } ~Array() { delete []_data; _data = nullptr; } size_t size() const { return _size; } size_t capacity() const { return _cap; } void push_back(T val) { if (_size \u0026gt;= _cap) { reserve(2 * _cap); } _data[_size++] = val; } T\u0026amp; operator[](size_t index) { if (index \u0026gt;= _size) { throw std::out_of_range(\u0026#34;Index out of range.\u0026#34;); } return _data[index]; } const T\u0026amp; operator[](size_t index) const { if (index \u0026gt;= _size) { throw std::out_of_range(\u0026#34;Index out of range.\u0026#34;); } return _data[index]; } T pop_back() { if (empty()) { throw std::out_of_range(\u0026#34;Array is empty, cannot pop back\u0026#34;); } return _data[_size--]; } void insert(iterator pos, const T\u0026amp; val) { if (pos \u0026lt; begin() || pos \u0026gt; end()) { throw std::out_of_range(\u0026#34;Insert position out of range\u0026#34;); } if (_size \u0026gt;= _cap) { reserve(2 * _cap); pos = _data + (pos - begin()); } for (iterator it = end(); it \u0026gt; pos; --it) { *it = *(it - 1); } *pos = val; ++_size; } void erase(iterator pos) { if (pos \u0026lt; begin() || pos \u0026gt;= end()) { throw std::out_of_range(\u0026#34;Erase position out of range\u0026#34;); } for (iterator it = pos; it \u0026lt; end() - 1; ++it) { *it = *(it + 1); } --_size; } void reserve(size_t cap) { if (cap \u0026lt;= _cap) { return; } T* new_data = new T[cap]; _cap = cap; for (size_t i = 0; i \u0026lt; size(); i++) { new_data[i] = _data[i]; } delete [] _data; _data = new_data; } void resize(size_t size) { if (size \u0026gt; _cap) { reserve(size); } _size = size; } iterator begin() { return _data; } iterator end() { return _data + _size; } const_iterator begin() const { return _data; } const_iterator end() const { return _data + _size; } bool empty() { return _size == 0; } private: T* _data; size_t _size; size_t _cap; }; int main() { try { // 测试构造和push_back Array\u0026lt;int\u0026gt; arr; arr.push_back(10); arr.push_back(20); arr.push_back(30); std::cout \u0026lt;\u0026lt; \u0026#34;Size: \u0026#34; \u0026lt;\u0026lt; arr.size() \u0026lt;\u0026lt; \u0026#34;, Capacity: \u0026#34; \u0026lt;\u0026lt; arr.capacity() \u0026lt;\u0026lt; std::endl; // 3,4 // 测试访问元素 for (size_t i = 0; i \u0026lt; arr.size(); ++i) { std::cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 10 20 30 } std::cout \u0026lt;\u0026lt; std::endl; // 测试迭代器 for (auto it = arr.begin(); it != arr.end(); ++it) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 10 20 30 } std::cout \u0026lt;\u0026lt; std::endl; // 测试插入 arr.insert(arr.begin() + 1, 15); std::cout \u0026lt;\u0026lt; \u0026#34;After insert: \u0026#34;; for (int val : arr) { // 范围for循环依赖迭代器 std::cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 10 15 20 30 } std::cout \u0026lt;\u0026lt; std::endl; // 测试删除 arr.erase(arr.begin() + 2); std::cout \u0026lt;\u0026lt; \u0026#34;After erase: \u0026#34;; for (int val : arr) { std::cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 10 15 30 } std::cout \u0026lt;\u0026lt; std::endl; // 测试拷贝构造 Array\u0026lt;int\u0026gt; arr2 = arr; arr2.push_back(40); std::cout \u0026lt;\u0026lt; \u0026#34;arr2: \u0026#34;; for (int val : arr2) { std::cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 10 15 30 40 } std::cout \u0026lt;\u0026lt; std::endl; } catch (const std::exception\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } return 0; } 环形数组 数组就是一块线性连续的内存空间，这一点很重要。\n环形数组技巧利用求模（余数）运算，将普通数组变成逻辑上的环形数组，可以让我们用 O(1) 的时间在数组头部增删元素。\n环形数组的关键在于，它维护了两个指针 start 和 end，start 指向第一个有效元素的索引，end 指向最后一个有效元素的下一个位置索引。\n这样，当我们在数组头部添加或删除元素时，只需要移动 start 索引，而在数组尾部添加或删除元素时，只需要移动 end 索引。当 start, end 移动超出数组边界（\u0026lt; 0 或 \u0026gt;= arr.length）时，我们可以通过求模运算 % 让它们转一圈到数组头部或尾部继续工作，这样就实现了环形数组的效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;stdexcept\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; template\u0026lt;typename T\u0026gt; struct CycleArray { public: CycleArray(size_t cap) : _size(0), _cap(cap) { _data.reserve(_cap); _start = _end = 0; } ~CycleArray() {} size_t size() const { return _size; } size_t capacity() const { return _cap; } void push(T val) { if (full()) { _start = (_start + 1) % _cap; } else { _size++; } _data[_end] = val; _end = (_end + 1) % _cap; } T pop() { if (empty()) { throw std::out_of_range(\u0026#34;CycleArray is empty. Cannot pop.\u0026#34;); } T item = _data[_start]; _start = (_start + 1) % _cap; _size--; return item; } const T\u0026amp; front() { if (empty()) { throw std::out_of_range(\u0026#34;CycleArray is empty, cannot pop back\u0026#34;); } return _data[_start]; } void reserve(size_t cap) { if (cap \u0026lt;= _cap) { return; } _data.reserve(cap); _cap = cap; } void resize(size_t size) { if (size \u0026gt; _cap) { _data.resize(size); } _size = size; } bool full() const { return _size == _cap; } bool empty() const { return _size == 0; } private: vector\u0026lt;T\u0026gt; _data; size_t _size; size_t _cap; size_t _start; size_t _end; }; // 辅助打印函数 template \u0026lt;typename T\u0026gt; void print_state(const CycleArray\u0026lt;T\u0026gt;\u0026amp; arr, const std::string\u0026amp; msg) { std::cout \u0026lt;\u0026lt; \u0026#34;--- \u0026#34; \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; \u0026#34; ---\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Size: \u0026#34; \u0026lt;\u0026lt; arr.size() \u0026lt;\u0026lt; \u0026#34;, Full: \u0026#34; \u0026lt;\u0026lt; (arr.full() ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;) \u0026lt;\u0026lt; \u0026#34;, Empty: \u0026#34; \u0026lt;\u0026lt; (arr.empty() ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;) \u0026lt;\u0026lt; std::endl; } void run_test() { std::cout \u0026lt;\u0026lt; \u0026#34;Starting CycleArray Test (Capacity = 4)\u0026#34; \u0026lt;\u0026lt; std::endl; CycleArray\u0026lt;int\u0026gt; arr(4); // ---------------------------------------------------- // Test 1: Basic Push and Pop (未满状态) // ---------------------------------------------------- arr.push(10); // [10, -, -, -] arr.push(20); // [10, 20, -, -] print_state(arr, \u0026#34;After pushing 10, 20\u0026#34;); // Output: Size: 2, Full: No, Empty: No std::cout \u0026lt;\u0026lt; \u0026#34;Front element: \u0026#34; \u0026lt;\u0026lt; arr.front() \u0026lt;\u0026lt; std::endl; // Output: 10 std::cout \u0026lt;\u0026lt; \u0026#34;Popped: \u0026#34; \u0026lt;\u0026lt; arr.pop() \u0026lt;\u0026lt; std::endl; // Output: 10. Buffer conceptually: [-, 20, -, -] print_state(arr, \u0026#34;After popping 10\u0026#34;); // Output: Size: 1, Full: No, Empty: No // ---------------------------------------------------- // Test 2: Filling and Wrap-around (填满和环绕) // ---------------------------------------------------- arr.push(30); // [-, 20, 30, -] arr.push(40); // [-, 20, 30, 40] arr.push(50); // [50, 20, 30, 40] - Now full, size 4 print_state(arr, \u0026#34;After filling to max (20, 30, 40, 50)\u0026#34;); // Output: Size: 4, Full: Yes, Empty: No // ---------------------------------------------------- // Test 3: Overwrite (覆盖) // ---------------------------------------------------- std::cout \u0026lt;\u0026lt; \u0026#34;\\nPushing 60 (should overwrite 20)\u0026#34; \u0026lt;\u0026lt; std::endl; arr.push(60); // [50, 60, 30, 40] - Head moves from 20 to 30 print_state(arr, \u0026#34;After pushing 60 (overwrite)\u0026#34;); // Output: Size: 4, Full: Yes, Empty: No std::cout \u0026lt;\u0026lt; \u0026#34;Popped: \u0026#34; \u0026lt;\u0026lt; arr.pop() \u0026lt;\u0026lt; std::endl; // Output: 30 (The oldest remaining element) std::cout \u0026lt;\u0026lt; \u0026#34;Popped: \u0026#34; \u0026lt;\u0026lt; arr.pop() \u0026lt;\u0026lt; std::endl; // Output: 40 std::cout \u0026lt;\u0026lt; \u0026#34;Popped: \u0026#34; \u0026lt;\u0026lt; arr.pop() \u0026lt;\u0026lt; std::endl; // Output: 50 print_state(arr, \u0026#34;After three more pops\u0026#34;); // Output: Size: 1, Full: No, Empty: No // ---------------------------------------------------- // Test 4: Empty and Exception Handling (清空和异常处理) // ---------------------------------------------------- std::cout \u0026lt;\u0026lt; \u0026#34;Popped: \u0026#34; \u0026lt;\u0026lt; arr.pop() \u0026lt;\u0026lt; std::endl; // Output: 60 print_state(arr, \u0026#34;After final pop\u0026#34;); // Output: Size: 0, Full: No, Empty: Yes // Try to pop from an empty array try { arr.pop(); } catch (const std::out_of_range\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;\\nCaught expected exception: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } } int main() { run_test(); return 0; } Reference https://labuladong.online/algo/data-structure-basic/cycle-array\nhttps://labuladong.online/algo/data-structure-basic/array-basic\n","date":"2025-10-27T15:04:14+08:00","permalink":"https://cold-rivers-snow.github.io/p/%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8/","title":"数组（顺序存储）"},{"content":"Reference https://brpc.apache.org/zh/docs/overview/ https://en.wikipedia.org/wiki/Remote_procedure_call\n","date":"2025-10-27T09:04:14+08:00","permalink":"https://cold-rivers-snow.github.io/p/brpc/","title":"brpc"},{"content":"Reference https://chai2010.cn/advanced-go-programming-book/\n","date":"2025-10-27T09:04:14+08:00","permalink":"https://cold-rivers-snow.github.io/p/golang/","title":"golang"},{"content":"并发编程有两种基本模型：\nmessage passing （消息传递） shared memory （共享内存） 分布式系统中，运行多台机器上的多个进程并发只有一种实用模型：message passing\n线程同步的四项原则：\n首先尽量最低限度地共享对象，减少需要同步地场合。一个对象能不暴露给别地线程不要暴露；如果要暴露，优先考虑 immutable 对象，实在不行才暴露可修改地对象，并用同步措施来充分保护它。 其次使用高级地并发编程构件。如 TaskQueue、Producer-Consumer Queue、CountDownLatch 等等。 最后不得已必须使用同步原语时，只用非递归地互斥器和条件变量，慎用读写锁，不要用信号量。 除了使用 atomic 整数之外，不自己编写 lock-free 代码，也不要用“内核级”同步原语。不凭空猜测“那种性能会更好”，比如 spin lock vs mutex. 互斥锁 原则：\n使用 RAII 手法操作 mutex 只用不可重入锁 不手动 lock() unlock(),交给 RAII 不用跨进程地锁，进程间只用 TCP sockets。 必要时候可以考虑用 PTHREAD_MUTEX_ERRORCHECK 来排错。 mutex 分为递归和非递归两种，这是 POSIX 地叫法，另外名字是可重入和非可重入，这两种唯一地区别是同一个线程可以重复对 recursive mutex 加锁，但是不能重复对 non-recursive mutex 加锁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026#34;../Mutex.h\u0026#34; #include \u0026#34;../Thread.h\u0026#34; #include \u0026lt;vector\u0026gt; #include \u0026lt;stdio.h\u0026gt; using namespace muduo; class Foo { public: void doit() const; }; MutexLock mutex; std::vector\u0026lt;Foo\u0026gt; foos; void post(const Foo\u0026amp; f) { MutexLockGuard lock(mutex); foos.push_back(f); } void traverse() { MutexLockGuard lock(mutex); for (std::vector\u0026lt;Foo\u0026gt;::const_iterator it = foos.begin(); it != foos.end(); ++it) { it-\u0026gt;doit(); } } void Foo::doit() const { Foo f; post(f); } int main() { Foo f; post(f); traverse(); } post() 和 traverse() 加锁都没问题 doit() 间接调用 post() 导致 mutex 非递归的会死锁，如果 mutex 为递归的，当 push_back() 可能会导致 vector 迭代器失效，程序偶尔 crash 死锁调试可以用 gdb 使用 thread apply all bt 指令\npost 可以拆成 2 个函数\n1 2 3 4 5 6 7 8 void post(const Foo\u0026amp; f) { MutexLockGuard lock(mutex); postWithLockHold(f); } void postWithLockHold(const Foo\u0026amp; f) { foos.push_back(f) } 误用加锁版本死锁，可以通过调试解决 误用不加锁版本，数据损坏了 1 2 3 4 void postWithLockHold(const Foo\u0026amp; f) { assert(mutex.isLockedByThisThread()); //muduo::MutexLock 提供了这个成员函数 foos.push_back(f) } windows 的 CRITICAL_SECTION 轻量级的，结合 spin lock。在多 cpu 系统上，如果不能立刻拿到锁，会先 spin 一小段时间，如果还不能拿到锁，才挂起当前线程。Linux 的 PTHREAD_MUTEX_ADAPTIVE_NP 与此类似\n死锁 死锁的条件\n条件名称 核心定义 示例 破坏该条件的方案 破坏方案示例 资源互斥（Mutual Exclusion） 资源只能被一个进程/线程独占，其他请求者必须等待（不可同时使用）。 打印机同一时间只能被一个程序使用；Java中的synchronized锁是独占锁。 用“共享资源”替代“独占资源”（仅适用于可共享场景） 将“独占打印机”改为“打印队列”（多进程共享队列，而非直接独占设备）。 持有并等待（Hold and Wait） 进程/线程已持有至少一个资源，同时又在等待其他进程/线程持有的资源。 线程A已获取“文件读锁”，又请求“文件写锁”（而写锁被线程B持有）。 要求进程/线程一次性获取所有所需资源，否则不持有任何资源 线程启动前，先申请“锁A+锁B”，只有两者都获取成功才执行；若缺一个，则释放已申请资源并等待。 不可剥夺（No Preemption） 进程/线程持有的资源不能被强制剥夺，只能由持有者主动释放。 线程A持有的锁，不能被系统强制收回，必须等A执行完unlock()才释放。 允许系统/其他进程强制剥夺已持有的资源（需资源支持“可剥夺”特性） 数据库事务中，若事务A等待事务B的锁超时，系统可强制回滚事务A，释放其持有的锁。 循环等待（Circular Wait） 多个进程/线程形成环形等待链，每个节点都等待下一个节点的资源。 线程1等线程2的锁，线程2等线程3的锁，线程3等线程1的锁，形成闭环。 给所有资源编号，要求进程/线程按“从小到大”的固定顺序获取资源 给锁A编号1、锁B编号2，所有线程必须先获取编号小的锁A，再获取编号大的锁B，避免循环。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026#34;../Mutex.h\u0026#34; class Request { public: void process() // __attribute__ ((noinline)) { muduo::MutexLockGuard lock(mutex_); print(); } void print() const // __attribute__ ((noinline)) { muduo::MutexLockGuard lock(mutex_); } private: mutable muduo::MutexLock mutex_; }; int main() { Request req; req.process(); } process 已经加锁，锁的作用域未整个函数，锁未释放前，调用函数 print 也加锁等待，持续等待无法退出，造成死锁现象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include \u0026#34;../Mutex.h\u0026#34; #include \u0026#34;../Thread.h\u0026#34; #include \u0026lt;set\u0026gt; #include \u0026lt;stdio.h\u0026gt; class Request; class Inventory { public: void add(Request* req) { muduo::MutexLockGuard lock(mutex_); requests_.insert(req); } void remove(Request* req) __attribute__ ((noinline)) { muduo::MutexLockGuard lock(mutex_); requests_.erase(req); } void printAll() const; private: mutable muduo::MutexLock mutex_; std::set\u0026lt;Request*\u0026gt; requests_; }; Inventory g_inventory; class Request { public: void process() // __attribute__ ((noinline)) { muduo::MutexLockGuard lock(mutex_); g_inventory.add(this); // ... } ~Request() __attribute__ ((noinline)) { muduo::MutexLockGuard lock(mutex_); sleep(1); g_inventory.remove(this); } void print() const __attribute__ ((noinline)) { muduo::MutexLockGuard lock(mutex_); // ... } private: mutable muduo::MutexLock mutex_; }; void Inventory::printAll() const { muduo::MutexLockGuard lock(mutex_); sleep(1); for (std::set\u0026lt;Request*\u0026gt;::const_iterator it = requests_.begin(); it != requests_.end(); ++it) { (*it)-\u0026gt;print(); } printf(\u0026#34;Inventory::printAll() unlocked\\n\u0026#34;); } /* void Inventory::printAll() const { std::set\u0026lt;Request*\u0026gt; requests { muduo::MutexLockGuard lock(mutex_); requests = requests_; } for (std::set\u0026lt;Request*\u0026gt;::const_iterator it = requests.begin(); it != requests.end(); ++it) { (*it)-\u0026gt;print(); } } */ void threadFunc() { Request* req = new Request; req-\u0026gt;process(); delete req; } int main() { muduo::Thread thread(threadFunc); thread.start(); usleep(500 * 1000); g_inventory.printAll(); thread.join(); } 这个是线程 threadFunc 调用 ~Request 获取了 Request 的锁， 主线程调用 printAll 获取了 Inventory 实例的锁，~Request 在调用 remove 后才会释放锁，而 remove 又等待 Inventory 实例的锁释放来移除 Request 实例，两个线程间导致死锁。\n条件变量 互斥锁是加锁原语，用来排他性的访问共享数据，它不是等待原语。使用 mutex 时，一般期望加锁不阻塞，能立刻拿到锁，尽快访问数据，尽快解锁，这样才不影响并发性和性能。\n如果需要等待某个条件成立，则使用条件变量。条件变量是一个或多个线程等待某个布尔表达式为真，即等待线程的唤醒。条件变量的学名为管程（monitor）。Java Object 内置的 wait()、notify()、notifyAll() 是条件变量。这三个函数容易用错，一般建议用 java.util.concurrent 中的同步原语。\n条件变量只有一种正确使用方式。对于 wait 端：\n必须与 mutex 一起使用，该布尔表达式的读写受锁的保护。 在 mutex 已经上锁的情况下，才调用 wait() 把判断布尔条件和 wait() 放到 while 循环中 1 2 3 4 5 6 7 8 9 10 muduo::MutexLock mutex; muduo::Condition cond(mutex); std::deque\u0026lt;int\u0026gt; queue; int dequeue() { MutexLockGuard lock(mutex); while (queue.empty) { //必须用循环；必须在判断之后再 wait() ; if 可能会 spurious wakeup cond.wait(); //这一步会原子地 unlock mutex 并进入等待，不会与 enqueue 死锁， wait() 执行完毕时会自动重新加锁 } } 对于 singal/broadcast 端：\n不一定要在 mutex 已上锁地情况下调用 signal。（理论上） 在 singal 之前一定要修改布尔表达式。 修改布尔表达式通常要用 mutex 保护（至少用在 full memory barrier）。 注意区分 singal 与 broadcast：“broadcast 通常用于表明状态变化，signal 通常用于表示资源可用。” 1 2 3 4 5 void enqueue(int x) { MutexLockGuard lock(mutex); queue.push_back(x); cond.notify(); //可用移出临界区之外 } 一般使用类模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 // excerpts from http://code.google.com/p/muduo/ // // Use of this source code is governed by a BSD-style license // that can be found in the License file. // // Author: Shuo Chen (giantchen at gmail dot com) #ifndef MUDUO_BASE_BLOCKINGQUEUE_H #define MUDUO_BASE_BLOCKINGQUEUE_H #include \u0026#34;Condition.h\u0026#34; #include \u0026#34;Mutex.h\u0026#34; #include \u0026lt;boost/noncopyable.hpp\u0026gt; #include \u0026lt;deque\u0026gt; #include \u0026lt;assert.h\u0026gt; namespace muduo { template\u0026lt;typename T\u0026gt; class BlockingQueue : boost::noncopyable { public: BlockingQueue() : mutex_(), notEmpty_(mutex_), queue_() { } void put(const T\u0026amp; x) { MutexLockGuard lock(mutex_); queue_.push_back(x); notEmpty_.notify(); } T take() { MutexLockGuard lock(mutex_); // always use a while-loop, due to spurious wakeup while (queue_.empty()) { notEmpty_.wait(); } assert(!queue_.empty()); T front(queue_.front()); queue_.pop_front(); return front; } size_t size() const { MutexLockGuard lock(mutex_); return queue_.size(); } private: mutable MutexLock mutex_; Condition notEmpty_; std::deque\u0026lt;T\u0026gt; queue_; }; } #endif // MUDUO_BASE_BLOCKINGQUEUE_H 倒计时（CountDownLatch）一种常见地同步手段，主要两个用途：\n主线程发起多个子线程，等待这些子线程各自完成一定地任务之后，主线程才继续执行。通常用于主线程等待多个子线程完成初始化。 主线程发起多个子线程，子线程都等待主线程，主线程完成其他的一下任务之后，通知所有子线程开始执行。通常用于多个子线程等待主线程发起“起跑”的命令。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 // excerpts from http://code.google.com/p/muduo/ // // Use of this source code is governed by a BSD-style license // that can be found in the License file. // // Author: Shuo Chen (giantchen at gmail dot com) #ifndef MUDUO_BASE_COUNTDOWNLATCH_H #define MUDUO_BASE_COUNTDOWNLATCH_H #include \u0026#34;Mutex.h\u0026#34; #include \u0026#34;Condition.h\u0026#34; #include \u0026lt;boost/noncopyable.hpp\u0026gt; namespace muduo { class CountDownLatch : boost::noncopyable { public: explicit CountDownLatch(int count) : mutex_(), condition_(mutex_), count_(count) { } void wait() { MutexLockGuard lock(mutex_); while (count_ \u0026gt; 0) { condition_.wait(); } } void countDown() { MutexLockGuard lock(mutex_); --count_; if (count_ == 0) { condition_.notifyAll(); } } int getCount() const { MutexLockGuard lock(mutex_); return count_; } private: mutable MutexLock mutex_; Condition condition_; int count_; }; } #endif // MUDUO_BASE_COUNTDOWNLATCH_H 不要用读写锁和信号量 正确性来说，可能修改代码读锁函数调用了修改状态的函数，导致共享数据被修改。 性能方面，读写锁不见得比 mutex 高效。 read lock 可能可以提升为 write lock。 read lock 可重入，write lock 不可重入，但为了防止 writer 饥饿， writer lock 通常会阻塞后来得 reader lock，因此 read locker 在重入得时候可能死锁。在追求低延迟读写得场合也不适合读写锁。对读写有极高得性能要求，可考虑 read-copy-update。 信号量：不是必备同步原语，条件变量加互斥锁完全可替代。同时信号量有自己得计数值，通常数据结构中也会有长度值，需要时刻保持一致，增加复杂度，控制并发度，可考虑 ThreadPool\n信号量（Semaphore）与互斥锁（Mutex）特性对比表 特性 信号量（Semaphore） 互斥锁（Mutex） 所有权 无（任何线程可获取/释放许可） 有（仅持有线程可释放锁） 典型操作示例 线程A获取许可后，线程B可释放该许可（语法合法） 线程A加锁后，线程B尝试解锁会触发错误（如死锁） 核心用途 控制并发访问数量（如限制5个线程同时访问资源） 保证资源独占访问（如同一时间仅1个线程操作共享数据） 封装 MutexLock 、MutexLockGuard 、Condition 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 // excerpts from http://code.google.com/p/muduo/ // // Use of this source code is governed by a BSD-style license // that can be found in the License file. // // Author: Shuo Chen (giantchen at gmail dot com) #ifndef MUDUO_BASE_MUTEX_H #define MUDUO_BASE_MUTEX_H #include \u0026#34;Thread.h\u0026#34; #include \u0026lt;boost/noncopyable.hpp\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; namespace muduo { class MutexLock : boost::noncopyable // C++ linux 端封装 mutex { public: MutexLock() : holder_(0) { pthread_mutex_init(\u0026amp;mutex_, NULL); } ~MutexLock() { assert(holder_ == 0); pthread_mutex_destroy(\u0026amp;mutex_); } bool isLockedByThisThread() { return holder_ == CurrentThread::tid(); } void assertLocked() { assert(isLockedByThisThread()); } // internal usage void lock() { pthread_mutex_lock(\u0026amp;mutex_); holder_ = CurrentThread::tid(); } void unlock() { holder_ = 0; pthread_mutex_unlock(\u0026amp;mutex_); } pthread_mutex_t* getPthreadMutex() /* non-const */ { return \u0026amp;mutex_; } private: pthread_mutex_t mutex_; pid_t holder_; }; class MutexLockGuard : boost::noncopyable //RAII 技术 { public: explicit MutexLockGuard(MutexLock\u0026amp; mutex) : mutex_(mutex) { mutex_.lock(); } ~MutexLockGuard() { mutex_.unlock(); } private: MutexLock\u0026amp; mutex_; }; } // Prevent misuse like: // MutexLockGuard(mutex_); // A tempory object doesn\u0026#39;t hold the lock for long! #define MutexLockGuard(x) error \u0026#34;Missing guard object name\u0026#34; //#define MutexLockGuard(x) static_assert(false, \u0026#34;Missing guard object name\u0026#34;) //书中用得断言方式 //这样写成宏，只要这样写就会报错，必须 MutexLockGuard lock(mutex); 定义，不能匿名定义 #endif // MUDUO_BASE_MUTEX_H 以上代码达不到工业强度：\nmutex 创建用PTHREAD_MUTEX_DEFAULT 类型，不是 PTHREAD_MUTEX_NORMAL 类型，严格说使用 mutexattr 指定锁类型 没有检测返回值。assert 使用 release build 会被优化成空语句。goolge-glog 的 CHECK() 宏是个思路。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 // excerpts from http://code.google.com/p/muduo/ // // Use of this source code is governed by a BSD-style license // that can be found in the License file. // // Author: Shuo Chen (giantchen at gmail dot com) #ifndef MUDUO_BASE_CONDITION_H #define MUDUO_BASE_CONDITION_H #include \u0026#34;Mutex.h\u0026#34; #include \u0026lt;boost/noncopyable.hpp\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;errno.h\u0026gt; namespace muduo { class Condition : boost::noncopyable { public: explicit Condition(MutexLock\u0026amp; mutex) : mutex_(mutex) { pthread_cond_init(\u0026amp;pcond_, NULL); } ~Condition() { pthread_cond_destroy(\u0026amp;pcond_); } void wait() { pthread_cond_wait(\u0026amp;pcond_, mutex_.getPthreadMutex()); } // returns true if time out, false otherwise. bool waitForSeconds(int seconds) { struct timespec abstime; clock_gettime(CLOCK_REALTIME, \u0026amp;abstime); abstime.tv_sec += seconds; return ETIMEDOUT == pthread_cond_timedwait(\u0026amp;pcond_, mutex_.getPthreadMutex(), \u0026amp;abstime); } void notify() { pthread_cond_signal(\u0026amp;pcond_); } void notifyAll() { pthread_cond_broadcast(\u0026amp;pcond_); } private: MutexLock\u0026amp; mutex_; pthread_cond_t pcond_; }; } #endif // MUDUO_BASE_CONDITION_H 像上面 CountDownLatch 代码，使用 mutex 和 condition 同时时，注意初始化顺序，先 mutex 后 condition\n线程安全的 Singleton 实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // excerpts from http://code.google.com/p/muduo/ // // Use of this source code is governed by a BSD-style license // that can be found in the License file. // // Author: Shuo Chen (giantchen at gmail dot com) #ifndef MUDUO_BASE_SINGLETON_H #define MUDUO_BASE_SINGLETON_H #include \u0026lt;boost/noncopyable.hpp\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // atexit namespace muduo { template\u0026lt;typename T\u0026gt; class Singleton : boost::noncopyable { public: static T\u0026amp; instance() { pthread_once(\u0026amp;ponce_, \u0026amp;Singleton::init); return *value_; } private: Singleton(); ~Singleton(); static void init() { value_ = new T(); ::atexit(destroy); } static void destroy() { delete value_; } private: static pthread_once_t ponce_; static T* value_; }; template\u0026lt;typename T\u0026gt; pthread_once_t Singleton\u0026lt;T\u0026gt;::ponce_ = PTHREAD_ONCE_INIT; template\u0026lt;typename T\u0026gt; T* Singleton\u0026lt;T\u0026gt;::value_ = NULL; } #endif sleep(3) 不是同步原语 生产代码中线程的等待分两种：一种是等待资源可用（要么等待在 select/poll/epoll_wait上，要么等待条件变量上）；一种是等待进入临界区（mutex 上）以便读取数据。后一种等待通常极短，否则程序的性能和伸缩性有问题。\n归纳总结 线程的四项原则，尽量使用高层同步设施（线程池、队列、倒计时）； 使用普通的互斥锁和条件变量完成剩余的同步任务，使用 RAII 手法和 Scoped Locking。 借 shared_ptr 实现 copy-on-write 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026#34;../Mutex.h\u0026#34; #include \u0026#34;../Thread.h\u0026#34; #include \u0026lt;vector\u0026gt; #include \u0026lt;boost/shared_ptr.hpp\u0026gt; #include \u0026lt;stdio.h\u0026gt; using namespace muduo; class Foo { public: void doit() const; }; typedef std::vector\u0026lt;Foo\u0026gt; FooList; typedef boost::shared_ptr\u0026lt;FooList\u0026gt; FooListPtr; FooListPtr g_foos; MutexLock mutex; void post(const Foo\u0026amp; f) { printf(\u0026#34;post\\n\u0026#34;); MutexLockGuard lock(mutex); if (!g_foos.unique()) { g_foos.reset(new FooList(*g_foos)); //复制当前容器内容创建新容器，再让共享指针指向新容器 printf(\u0026#34;copy the whole list\\n\u0026#34;); } assert(g_foos.unique()); //新的为 1 写入数据。另一份通过 shared_ptr 自动管理生命周期释放。 g_foos-\u0026gt;push_back(f); } void traverse() { FooListPtr foos; { MutexLockGuard lock(mutex); //多线程读写 shared_ptr ,必须用 mutex 保护 foos = g_foos; assert(!g_foos.unique()); } // assert(!foos.unique()); this may not hold for (std::vector\u0026lt;Foo\u0026gt;::const_iterator it = foos-\u0026gt;begin(); it != foos-\u0026gt;end(); ++it) { it-\u0026gt;doit(); } } void Foo::doit() const { Foo f; post(f); } int main() { g_foos.reset(new FooList); Foo f; post(f); traverse(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 #include \u0026#34;../Mutex.h\u0026#34; #include \u0026#34;../Thread.h\u0026#34; #include \u0026lt;set\u0026gt; #include \u0026lt;boost/shared_ptr.hpp\u0026gt; #include \u0026lt;stdio.h\u0026gt; class Request; class Inventory { public: Inventory() : requests_(new RequestList) { } void add(Request* req) { muduo::MutexLockGuard lock(mutex_); if (!requests_.unique()) { requests_.reset(new RequestList(*requests_)); printf(\u0026#34;Inventory::add() copy the whole list\\n\u0026#34;); } assert(requests_.unique()); requests_-\u0026gt;insert(req); } void remove(Request* req) // __attribute__ ((noinline)) { muduo::MutexLockGuard lock(mutex_); if (!requests_.unique()) { requests_.reset(new RequestList(*requests_)); printf(\u0026#34;Inventory::remove() copy the whole list\\n\u0026#34;); } assert(requests_.unique()); requests_-\u0026gt;erase(req); } void printAll() const; private: typedef std::set\u0026lt;Request*\u0026gt; RequestList; typedef boost::shared_ptr\u0026lt;RequestList\u0026gt; RequestListPtr; RequestListPtr getData() const { muduo::MutexLockGuard lock(mutex_); return requests_; } mutable muduo::MutexLock mutex_; RequestListPtr requests_; }; Inventory g_inventory; class Request { public: Request() : x_(0) { } ~Request() __attribute__ ((noinline)) { muduo::MutexLockGuard lock(mutex_); x_ = -1; sleep(1); g_inventory.remove(this); } void process() // __attribute__ ((noinline)) { muduo::MutexLockGuard lock(mutex_); g_inventory.add(this); // ... } void print() const __attribute__ ((noinline)) { muduo::MutexLockGuard lock(mutex_); // ... printf(\u0026#34;print Request %p x=%d\\n\u0026#34;, this, x_); } private: mutable muduo::MutexLock mutex_; int x_; }; void Inventory::printAll() const { RequestListPtr requests = getData(); sleep(1); for (std::set\u0026lt;Request*\u0026gt;::const_iterator it = requests-\u0026gt;begin(); it != requests-\u0026gt;end(); ++it) { (*it)-\u0026gt;print(); } } void threadFunc() { Request* req = new Request; req-\u0026gt;process(); delete req; } int main() { muduo::Thread thread(threadFunc); thread.start(); usleep(500*1000); g_inventory.printAll(); thread.join(); } Request 析构的 race condition 解决\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 #include \u0026#34;../Mutex.h\u0026#34; #include \u0026#34;../Thread.h\u0026#34; #include \u0026lt;set\u0026gt; #include \u0026lt;boost/shared_ptr.hpp\u0026gt; #include \u0026lt;boost/enable_shared_from_this.hpp\u0026gt; #include \u0026lt;stdio.h\u0026gt; class Request; typedef boost::shared_ptr\u0026lt;Request\u0026gt; RequestPtr; class Inventory { public: Inventory() : requests_(new RequestList) { } void add(const RequestPtr\u0026amp; req) { muduo::MutexLockGuard lock(mutex_); if (!requests_.unique()) { requests_.reset(new RequestList(*requests_)); printf(\u0026#34;Inventory::add() copy the whole list\\n\u0026#34;); } assert(requests_.unique()); requests_-\u0026gt;insert(req); } void remove(const RequestPtr\u0026amp; req) // __attribute__ ((noinline)) { muduo::MutexLockGuard lock(mutex_); if (!requests_.unique()) { requests_.reset(new RequestList(*requests_)); printf(\u0026#34;Inventory::remove() copy the whole list\\n\u0026#34;); } assert(requests_.unique()); requests_-\u0026gt;erase(req); } void printAll() const; private: typedef std::set\u0026lt;RequestPtr\u0026gt; RequestList; typedef boost::shared_ptr\u0026lt;RequestList\u0026gt; RequestListPtr; RequestListPtr getData() const { muduo::MutexLockGuard lock(mutex_); return requests_; } mutable muduo::MutexLock mutex_; RequestListPtr requests_; }; Inventory g_inventory; class Request : public boost::enable_shared_from_this\u0026lt;Request\u0026gt; { public: Request() : x_(0) { } ~Request() { x_ = -1; } void cancel() __attribute__ ((noinline)) { muduo::MutexLockGuard lock(mutex_); x_ = 1; sleep(1); printf(\u0026#34;cancel()\\n\u0026#34;); g_inventory.remove(shared_from_this()); } void process() // __attribute__ ((noinline)) { muduo::MutexLockGuard lock(mutex_); g_inventory.add(shared_from_this()); // ... } void print() const __attribute__ ((noinline)) { muduo::MutexLockGuard lock(mutex_); // ... printf(\u0026#34;print Request %p x=%d\\n\u0026#34;, this, x_); } private: mutable muduo::MutexLock mutex_; int x_; }; void Inventory::printAll() const { RequestListPtr requests = getData(); printf(\u0026#34;printAll()\\n\u0026#34;); sleep(1); for (std::set\u0026lt;RequestPtr\u0026gt;::const_iterator it = requests-\u0026gt;begin(); it != requests-\u0026gt;end(); ++it) { (*it)-\u0026gt;print(); } } void threadFunc() { RequestPtr req(new Request); req-\u0026gt;process(); req-\u0026gt;cancel(); } int main() { muduo::Thread thread(threadFunc); thread.start(); usleep(500*1000); g_inventory.printAll(); thread.join(); } 普通 mutex 替换读写锁 背景线程读写，工作线程只读。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;map\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;boost/shared_ptr.hpp\u0026gt; #include \u0026#34;../Mutex.h\u0026#34; using std::string; class CustomerData : boost::noncopyable { public: CustomerData() : data_(new Map) { } int query(const string\u0026amp; customer, const string\u0026amp; stock) const; private: typedef std::pair\u0026lt;string, int\u0026gt; Entry; typedef std::vector\u0026lt;Entry\u0026gt; EntryList; typedef std::map\u0026lt;string, EntryList\u0026gt; Map; typedef boost::shared_ptr\u0026lt;Map\u0026gt; MapPtr; void update(const string\u0026amp; customer, const EntryList\u0026amp; entries); void update(const string\u0026amp; message); static int findEntry(const EntryList\u0026amp; entries, const string\u0026amp; stock); static MapPtr parseData(const string\u0026amp; message); MapPtr getData() const { muduo::MutexLockGuard lock(mutex_); return data_; } mutable muduo::MutexLock mutex_; MapPtr data_; }; int CustomerData::query(const string\u0026amp; customer, const string\u0026amp; stock) const { MapPtr data = getData(); Map::const_iterator entries = data-\u0026gt;find(customer); if (entries != data-\u0026gt;end()) return findEntry(entries-\u0026gt;second, stock); else return -1; } void CustomerData::update(const string\u0026amp; customer, const EntryList\u0026amp; entries) { muduo::MutexLockGuard lock(mutex_); if (!data_.unique()) { MapPtr newData(new Map(*data_)); data_.swap(newData); } assert(data_.unique()); (*data_)[customer] = entries; } void CustomerData::update(const string\u0026amp; message) { MapPtr newData = parseData(message); if (newData) { muduo::MutexLockGuard lock(mutex_); data_.swap(newData); } } int main() { CustomerData data; } Reference http://queue.acm.org/detail.cfm?id=1454462\nhttps://computing.llnl.gov/tutorials/pthreads\nhttp://www.thinkingparallel.com/2007/02/19/please-dont-rely-on-memory-barriers-for-synchronization/\nhttp://zaitcev.livejournal.com/144041.html\nhttp://www.kernel.org/doc/Documentation/volatile-considered-harmful.txt\nhttp://www.cs.wustl.edu/~schrnidt/PDF/locking-patterns.pdf Douglas Schmidt 论文\nhttp://llvm.org/devmtg/2011-11/#talk3\nhttp://zaval.org/resources/library/butenhof1.html\nhttp://www.akkadia.org/drepper/futex.pdf\nhttp://msdn.microsoft.com/en-us/library/windows/desktop/ms682530(v=vs.85).aspx\nhttp://blog.csdn.net/panaimin/article/details/5981766\nhttp://www.nwcpp.org/Downloads/2007/Machine_Architecture_-_NWCPP.pdf\nhttp://www.aristeia.com/TalkNotes/ACCU2011_CPUCaches.pdf\nhttp://igoro.com/archive/gallery-of-processor-cache-effects/\nhttp://simplygenius.net/Article/FalseSharing\nhttp://blog.csdn.net/solstice/article/details/11432817 http://blog.csdn.net/solstice/article/details/5829421#comments\nhttp://en.wikipedia.org/wiki/Spurious_wakeup\nhttp://en.wikipedia.org/wiki/Read-copy-update\nhttps://www.artima.com/shop/effective_cpp_in_an_embedded_environment\nhttp://www.drdobbs.com/cpp/lock-free-code-a-false-sense-of-security/210600279\nIntel Thread Ckecker\nValgrind-Helgrind\nhttp://valgrind.org/docs/manual/hg-manual.html/#hg-manual.data-races.algorithm\nhttp://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf\nhttp://www.cs.wustl.edu/~schmidt/PDF/DC-Locking.pdf\nhttp://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html\nhttp://www.javaworld.com/jw-02-2001/jw-0209-double.html\nhttp://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf\nhttp://scottmeyers.blogspot.com/2012/04/information-on-c11-memory-model.html\n《Ad Hoc Synchronization Considered Harmful》 http://www.usenix.org/events/osdi10/tech/full_papers/Xiong.pdf\nhttp://pdos.csail.mit.edu/papers/linux:osdi10.pdf\nhttp://preshing.com/20111118/locks-arent-slow-lock-contention-is\n《Programming with POSIX Threads》\nRWC\n","date":"2025-10-26T20:04:14+08:00","permalink":"https://cold-rivers-snow.github.io/p/02%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%B2%BE%E8%A6%81/","title":"02线程同步精要"},{"content":"多线程下析构函数 race condition 析构对象时，是否有其他线程正在执行这个对象的其他成员函数等操作。 对象执行操作，没有其他线程析构。 对象操作或者析构之前，确定对象存活，没有其他线程操作。 shared_ptr 解决。\n线程安全定义 一个线程安全的 class 满足的三个条件：\n多线程同时访问，表现正确 不管操作系统如何调度、线程执行顺序如何 调用端代码无须额外的同步或其他协调动作 根据此要求，c++ 标准库中的 string、vector、map 等类型都不满足要求，需要加锁使用。\nMutexLock 和 MutexLockGuard 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 // excerpts from http://code.google.com/p/muduo/ // // Use of this source code is governed by a BSD-style license // that can be found in the License file. // // Author: Shuo Chen (giantchen at gmail dot com) #ifndef MUDUO_BASE_MUTEX_H #define MUDUO_BASE_MUTEX_H #include \u0026#34;Thread.h\u0026#34; #include \u0026lt;boost/noncopyable.hpp\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; namespace muduo { class MutexLock : boost::noncopyable // C++ linux 端封装 mutex { public: MutexLock() : holder_(0) { pthread_mutex_init(\u0026amp;mutex_, NULL); } ~MutexLock() { assert(holder_ == 0); pthread_mutex_destroy(\u0026amp;mutex_); } bool isLockedByThisThread() { return holder_ == CurrentThread::tid(); } void assertLocked() { assert(isLockedByThisThread()); } // internal usage void lock() { pthread_mutex_lock(\u0026amp;mutex_); holder_ = CurrentThread::tid(); } void unlock() { holder_ = 0; pthread_mutex_unlock(\u0026amp;mutex_); } pthread_mutex_t* getPthreadMutex() /* non-const */ { return \u0026amp;mutex_; } private: pthread_mutex_t mutex_; pid_t holder_; }; class MutexLockGuard : boost::noncopyable //RAII 技术 { public: explicit MutexLockGuard(MutexLock\u0026amp; mutex) : mutex_(mutex) { mutex_.lock(); } ~MutexLockGuard() { mutex_.unlock(); } private: MutexLock\u0026amp; mutex_; }; } // Prevent misuse like: // MutexLockGuard(mutex_); // A tempory object doesn\u0026#39;t hold the lock for long! #define MutexLockGuard(x) error \u0026#34;Missing guard object name\u0026#34; //#define MutexLockGuard(x) static_assert(false, \u0026#34;Missing guard object name\u0026#34;) //书中用得断言方式 //这样写成宏，只要这样写就会报错，必须 MutexLockGuard lock(mutex); 定义，不能匿名定义 #endif // MUDUO_BASE_MUTEX_H 特性 重入锁（递归锁） 不可重入锁（默认） 同一线程加锁次数 允许多次加锁 仅允许一次加锁 死锁风险 需保证解锁次数与加锁次数一致，否则仍会死锁 同一线程多次加锁直接死锁 创建方式 需显式设置属性 默认即支持 性能开销 略高（需维护锁的递归计数） 开销低 适用场景 递归函数、同一线程多步骤加锁 简单互斥场景，避免逻辑错误 c++11 实现的自旋锁，也是不可重入的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 // Copyright (c) 2020 by Chrono #ifndef _SPIN_LOCK_HPP #define _SPIN_LOCK_HPP #include \u0026#34;cpplang.hpp\u0026#34; BEGIN_NAMESPACE(cpp_study) // atomic spinlock with TAS class SpinLock final { public: using this_type = SpinLock; using atomic_type = std::atomic_flag; public: SpinLock() = default; ~SpinLock() = default; SpinLock(const this_type\u0026amp;) = delete; SpinLock\u0026amp; operator=(const this_type\u0026amp;) = delete; public: void lock() noexcept { for(;;) { if (!m_lock.test_and_set()) { return; } std::this_thread::yield(); } } bool try_lock() noexcept { return !m_lock.test_and_set(); } void unlock() noexcept { m_lock.clear(); } private: atomic_type m_lock {false}; }; // RAII for lock // you can change it to a template class class SpinLockGuard final { public: using this_type = SpinLockGuard; using spin_lock_type = SpinLock; public: SpinLockGuard(spin_lock_type\u0026amp; lock) noexcept : m_lock(lock) { m_lock.lock(); } ~SpinLockGuard() noexcept { m_lock.unlock(); } public: SpinLockGuard(const this_type\u0026amp;) = delete; SpinLockGuard\u0026amp; operator=(const this_type\u0026amp;) = delete; private: spin_lock_type\u0026amp; m_lock; }; END_NAMESPACE(cpp_study) #endif //_SPIN_LOCK_HPP 锁的分类与核心特性 1. 按「线程等待机制」分类 锁类型 核心特征（等待机制） 适用场景 典型示例 自旋锁 忙等待：获取锁失败时，线程循环重试（不挂起），通过 yield() 让出 CPU，但保持运行态。 锁持有时间极短（微秒级），避免线程阻塞/唤醒的内核开销。 std::atomic_flag 实现的自旋锁、Linux 内核 spinlock_t。 互斥锁 阻塞等待：获取锁失败时，线程被内核挂起（阻塞态），锁释放时由内核唤醒。 锁持有时间较长（毫秒级），避免自旋导致的 CPU 空耗。 std::mutex、pthread_mutex_t（默认类型）。 2. 按「重入性」分类 锁类型 核心特征（同一线程重复加锁） 典型示例 不可重入锁 同一线程对已持有的锁再次加锁会导致死锁。 默认 std::mutex、基础自旋锁实现。 可重入锁 同一线程可多次加锁，需通过「线程 ID + 递归计数」实现（解锁次数需匹配）。 std::recursive_mutex、PTHREAD_MUTEX_RECURSIVE 类型的 pthread_mutex_t。 3. 按「竞争范围」分类 锁类型 核心特征（竞争资源的范围） 典型示例 线程锁 仅同一进程内的线程竞争，锁状态存储在进程地址空间（用户态）。 std::mutex、自旋锁、pthread_mutex_t。 进程锁 多进程间竞争，锁状态存储在共享资源（文件、共享内存）。 文件锁（fcntl）、System V 信号量。 4. 按「功能特性」分类（特定场景优化） 锁类型 核心特征（功能优化） 适用场景 典型示例 读写锁 区分读写操作：多线程同时读（共享），写操作独占（互斥）。 读多写少场景（如缓存、配置文件）。 std::shared_mutex（C++17）、pthread_rwlock_t。 条件变量 配合互斥锁实现「等待-通知」机制，解决盲目等待问题。 生产者-消费者模型、线程同步信号。 std::condition_variable、pthread_cond_t。 信号量 通过计数器控制资源访问数量（支持 N 个并发访问）。 限制资源并发数（如连接池、线程池）。 std::counting_semaphore（C++20）、POSIX 信号量。 对象的创建 对象构造要做到线程安全，就不能在构造期间泄露 this 指针\n不要再构造函数中注册任何回调 不要再构造函数中把 this 传递给跨线程的对象 对象析构 避免悬空指针和野指针\n悬空指针：指向已经消毁的对象或已经回收的地址 野指针：未初始化的指针\n面向对象设计中，对象的关系主要有三种：composition（组合/复合）、aggregation（聚合）、asscoiation（关联/联系）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stdio.h\u0026gt; class Observable; class Observer { public: virtual ~Observer(); virtual void update() = 0; void observe(Observable* s); protected: Observable* subject_; }; class Observable { public: void register_(Observer* x); void unregister(Observer* x); void notifyObservers() { for (size_t i = 0; i \u0026lt; observers_.size(); ++i) { Observer* x = observers_[i]; if (x) { x-\u0026gt;update(); // (3) } } } private: std::vector\u0026lt;Observer*\u0026gt; observers_; }; Observer::~Observer() { subject_-\u0026gt;unregister(this); } void Observer::observe(Observable* s) { s-\u0026gt;register_(this); subject_ = s; } void Observable::register_(Observer* x) { observers_.push_back(x); } void Observable::unregister(Observer* x) { std::vector\u0026lt;Observer*\u0026gt;::iterator it = std::find(observers_.begin(), observers_.end(), x); if (it != observers_.end()) { std::swap(*it, observers_.back()); observers_.pop_back(); } } // --------------------- class Foo : public Observer { virtual void update() { printf(\u0026#34;Foo::update() %p\\n\u0026#34;, this); } }; int main() { Foo* p = new Foo; Observable subject; p-\u0026gt;observe(\u0026amp;subject); subject.notifyObservers(); delete p; subject.notifyObservers(); } shared_ptr 和 weak_ptr shared_ptr 强引用控制对象生命周期，指向的对象，直到最后一个没有析构或者reset() weak_ptr 弱引用不控制对象生命周期，但是知道对象是否还活着，可以提升为 shared_ptr, 提升/lock() 是线程安全的 shared_ptr、weak_ptr 主流平台实现都没有用所，用原子能力，性能可以。 shared_ptr、weak_ptr、scoped_ptr 都是值语义 c++ 中内存错误大致几个方面：\n缓冲区溢出 ： 用std::vector/std::string 或自己编写的 Buffer Class 做缓冲区，自动记住缓冲区长度，并通过成员函数而不是裸指针来修改缓冲区 悬空指针/野指针：用 shared_ptr/weak_ptr 重复释放：用 scoped_ptr, 只对对象析构时候释放一次 内存泄漏：用 scoped_ptr, 对象析构时候自动释放内存 不配对的 new[]/delete：把 net[]/delete 改为std::vector/scoped_array 内存碎片 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;../Mutex.h\u0026#34; #include \u0026lt;boost/enable_shared_from_this.hpp\u0026gt; #include \u0026lt;boost/shared_ptr.hpp\u0026gt; #include \u0026lt;boost/weak_ptr.hpp\u0026gt; class Observable; class Observer : public boost::enable_shared_from_this\u0026lt;Observer\u0026gt; { public: virtual ~Observer(); virtual void update() = 0; void observe(Observable* s); protected: Observable* subject_; }; class Observable { public: void register_(boost::weak_ptr\u0026lt;Observer\u0026gt; x); // void unregister(boost::weak_ptr\u0026lt;Observer\u0026gt; x); void notifyObservers() { muduo::MutexLockGuard lock(mutex_); Iterator it = observers_.begin(); while (it != observers_.end()) { boost::shared_ptr\u0026lt;Observer\u0026gt; obj(it-\u0026gt;lock()); if (obj) { obj-\u0026gt;update(); ++it; } else { printf(\u0026#34;notifyObservers() erase\\n\u0026#34;); it = observers_.erase(it); } } } private: mutable muduo::MutexLock mutex_; std::vector\u0026lt;boost::weak_ptr\u0026lt;Observer\u0026gt; \u0026gt; observers_; typedef std::vector\u0026lt;boost::weak_ptr\u0026lt;Observer\u0026gt; \u0026gt;::iterator Iterator; }; Observer::~Observer() { // subject_-\u0026gt;unregister(this); } void Observer::observe(Observable* s) { s-\u0026gt;register_(shared_from_this()); subject_ = s; } void Observable::register_(boost::weak_ptr\u0026lt;Observer\u0026gt; x) { observers_.push_back(x); } //void Observable::unregister(boost::weak_ptr\u0026lt;Observer\u0026gt; x) //{ // Iterator it = std::find(observers_.begin(), observers_.end(), x); // observers_.erase(it); //} // --------------------- class Foo : public Observer { virtual void update() { printf(\u0026#34;Foo::update() %p\\n\u0026#34;, this); } }; int main() { Observable subject; { boost::shared_ptr\u0026lt;Foo\u0026gt; p(new Foo); p-\u0026gt;observe(\u0026amp;subject); subject.notifyObservers(); } subject.notifyObservers(); } 多线程中同时访问同一个 shared_ptr,正确的做法加锁\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 MutexLock mutex; shared_ptr\u0026lt;Foo\u0026gt; globalPtr; void doit(const shared_ptr\u0026lt;Foo\u0026gt;\u0026amp; pFoo); void read() { shared_ptr\u0026lt;Foo\u0026gt; ptr; { MutexLock lock(mutex); ptr = globalPtr; // read globalPtr } // use ptr since here doit(ptr); } //写入的时候也要加锁： void write() { shared_ptr\u0026lt;Foo\u0026gt; newptr(new Foo); { MutexLock lock(mutex); globalPtr = newptr; // write to globalPtr } // use newptr since here doit(newptr); } 对象池 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 #include \u0026lt;map\u0026gt; #include \u0026lt;boost/bind.hpp\u0026gt; #include \u0026lt;boost/enable_shared_from_this.hpp\u0026gt; #include \u0026lt;boost/shared_ptr.hpp\u0026gt; #include \u0026lt;boost/weak_ptr.hpp\u0026gt; #include \u0026#34;../Mutex.h\u0026#34; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; using std::string; class Stock : boost::noncopyable { public: Stock(const string\u0026amp; name) : name_(name) { printf(\u0026#34; Stock[%p] %s\\n\u0026#34;, this, name_.c_str()); } ~Stock() { printf(\u0026#34;~Stock[%p] %s\\n\u0026#34;, this, name_.c_str()); } const string\u0026amp; key() const { return name_; } private: string name_; }; namespace version1 { // questionable code class StockFactory : boost::noncopyable { public: boost::shared_ptr\u0026lt;Stock\u0026gt; get(const string\u0026amp; key) { muduo::MutexLockGuard lock(mutex_); boost::shared_ptr\u0026lt;Stock\u0026gt;\u0026amp; pStock = stocks_[key]; if (!pStock) { pStock.reset(new Stock(key)); } return pStock; } private: mutable muduo::MutexLock mutex_; std::map\u0026lt;string, boost::shared_ptr\u0026lt;Stock\u0026gt; \u0026gt; stocks_; }; } namespace version2 { class StockFactory : boost::noncopyable { public: boost::shared_ptr\u0026lt;Stock\u0026gt; get(const string\u0026amp; key) { boost::shared_ptr\u0026lt;Stock\u0026gt; pStock; muduo::MutexLockGuard lock(mutex_); boost::weak_ptr\u0026lt;Stock\u0026gt;\u0026amp; wkStock = stocks_[key]; pStock = wkStock.lock(); if (!pStock) { pStock.reset(new Stock(key)); wkStock = pStock; } return pStock; } private: mutable muduo::MutexLock mutex_; std::map\u0026lt;string, boost::weak_ptr\u0026lt;Stock\u0026gt; \u0026gt; stocks_; }; } namespace version3 { class StockFactory : boost::noncopyable { public: boost::shared_ptr\u0026lt;Stock\u0026gt; get(const string\u0026amp; key) { boost::shared_ptr\u0026lt;Stock\u0026gt; pStock; muduo::MutexLockGuard lock(mutex_); boost::weak_ptr\u0026lt;Stock\u0026gt;\u0026amp; wkStock = stocks_[key]; pStock = wkStock.lock(); if (!pStock) { pStock.reset(new Stock(key), boost::bind(\u0026amp;StockFactory::deleteStock, this, _1)); wkStock = pStock; } return pStock; } private: void deleteStock(Stock* stock) { printf(\u0026#34;deleteStock[%p]\\n\u0026#34;, stock); if (stock) { muduo::MutexLockGuard lock(mutex_); stocks_.erase(stock-\u0026gt;key()); // This is wrong, see removeStock below for correct implementation. } delete stock; // sorry, I lied } mutable muduo::MutexLock mutex_; std::map\u0026lt;string, boost::weak_ptr\u0026lt;Stock\u0026gt; \u0026gt; stocks_; }; } namespace version4 { class StockFactory : public boost::enable_shared_from_this\u0026lt;StockFactory\u0026gt;, boost::noncopyable { public: boost::shared_ptr\u0026lt;Stock\u0026gt; get(const string\u0026amp; key) { boost::shared_ptr\u0026lt;Stock\u0026gt; pStock; muduo::MutexLockGuard lock(mutex_); boost::weak_ptr\u0026lt;Stock\u0026gt;\u0026amp; wkStock = stocks_[key]; pStock = wkStock.lock(); if (!pStock) { pStock.reset(new Stock(key), boost::bind(\u0026amp;StockFactory::deleteStock, shared_from_this(), // shared_ptr\u0026lt;StockFactory\u0026gt; _1)); wkStock = pStock; } return pStock; } private: void deleteStock(Stock* stock) { printf(\u0026#34;deleteStock[%p]\\n\u0026#34;, stock); if (stock) { muduo::MutexLockGuard lock(mutex_); stocks_.erase(stock-\u0026gt;key()); // This is wrong, see removeStock below for correct implementation. } delete stock; // sorry, I lied } mutable muduo::MutexLock mutex_; std::map\u0026lt;string, boost::weak_ptr\u0026lt;Stock\u0026gt; \u0026gt; stocks_; }; } class StockFactory : public boost::enable_shared_from_this\u0026lt;StockFactory\u0026gt;, boost::noncopyable { public: boost::shared_ptr\u0026lt;Stock\u0026gt; get(const string\u0026amp; key) { boost::shared_ptr\u0026lt;Stock\u0026gt; pStock; muduo::MutexLockGuard lock(mutex_); boost::weak_ptr\u0026lt;Stock\u0026gt;\u0026amp; wkStock = stocks_[key]; pStock = wkStock.lock(); if (!pStock) { pStock.reset(new Stock(key), boost::bind(\u0026amp;StockFactory::weakDeleteCallback, boost::weak_ptr\u0026lt;StockFactory\u0026gt;(shared_from_this()), _1)); //必须显示将 shared_from_this() 转换为 weak_ptr 类型，bind 拷贝的是实参类型，不是形参类型，只负责拷贝实参本身（无论其类型是否与函数形参匹配），因此实参必须是可拷贝的（或可移动的） wkStock = pStock; } return pStock; } private: static void weakDeleteCallback(const boost::weak_ptr\u0026lt;StockFactory\u0026gt;\u0026amp; wkFactory, Stock* stock) { printf(\u0026#34;weakDeleteStock[%p]\\n\u0026#34;, stock); boost::shared_ptr\u0026lt;StockFactory\u0026gt; factory(wkFactory.lock()); if (factory) { factory-\u0026gt;removeStock(stock); } else { printf(\u0026#34;factory died.\\n\u0026#34;); } delete stock; // sorry, I lied } void removeStock(Stock* stock) { if (stock) { muduo::MutexLockGuard lock(mutex_); auto it = stocks_.find(stock-\u0026gt;key()); if (it != stocks_.end() \u0026amp;\u0026amp; it-\u0026gt;second.expired()) { stocks_.erase(stock-\u0026gt;key()); } } } private: mutable muduo::MutexLock mutex_; std::map\u0026lt;string, boost::weak_ptr\u0026lt;Stock\u0026gt; \u0026gt; stocks_; }; void testLongLifeFactory() { boost::shared_ptr\u0026lt;StockFactory\u0026gt; factory(new StockFactory); { boost::shared_ptr\u0026lt;Stock\u0026gt; stock = factory-\u0026gt;get(\u0026#34;NYSE:IBM\u0026#34;); boost::shared_ptr\u0026lt;Stock\u0026gt; stock2 = factory-\u0026gt;get(\u0026#34;NYSE:IBM\u0026#34;); assert(stock == stock2); // stock destructs here } // factory destructs here } void testShortLifeFactory() { boost::shared_ptr\u0026lt;Stock\u0026gt; stock; { boost::shared_ptr\u0026lt;StockFactory\u0026gt; factory(new StockFactory); stock = factory-\u0026gt;get(\u0026#34;NYSE:IBM\u0026#34;); boost::shared_ptr\u0026lt;Stock\u0026gt; stock2 = factory-\u0026gt;get(\u0026#34;NYSE:IBM\u0026#34;); assert(stock == stock2); // factory destructs here } // stock destructs here } int main() { version1::StockFactory sf1; version2::StockFactory sf2; version3::StockFactory sf3; boost::shared_ptr\u0026lt;version3::StockFactory\u0026gt; sf4(new version3::StockFactory); boost::shared_ptr\u0026lt;StockFactory\u0026gt; sf5(new StockFactory); { boost::shared_ptr\u0026lt;Stock\u0026gt; s1 = sf1.get(\u0026#34;stock1\u0026#34;); } { boost::shared_ptr\u0026lt;Stock\u0026gt; s2 = sf2.get(\u0026#34;stock2\u0026#34;); } { boost::shared_ptr\u0026lt;Stock\u0026gt; s3 = sf3.get(\u0026#34;stock3\u0026#34;); } { boost::shared_ptr\u0026lt;Stock\u0026gt; s4 = sf4-\u0026gt;get(\u0026#34;stock4\u0026#34;); } { boost::shared_ptr\u0026lt;Stock\u0026gt; s5 = sf5-\u0026gt;get(\u0026#34;stock5\u0026#34;); } testLongLifeFactory(); testShortLifeFactory(); } enable_shared_from_this 以派生类为模板类型实参的基类模板，继承它，this 指针变为 shared_ptr类型\nshared_from_this() 不能在构造函数中调用，因为类型的构造函数中还没有交给 shared_ptr 管理生命周期\n把 shared_ptr 邦（std::bind）到 boost::function 里，那么回调的时候 StockFactory 对象始终存在，是安全的，延长了对象的生命周期，使得不短于邦的 boost::function 对象。\n使用 weak_ptr 邦到 boost::function 这样，对象的生命周期不会延长，然后再回调的时候尝试提升为 shared_ptr，如果提升成功，说明接受回调的对象还健在，那么执行回调，如果失败，则不处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 // excerpts from http://code.google.com/p/muduo/ // // Use of this source code is governed by a BSD-style license // that can be found in the License file. // // Author: Shuo Chen (giantchen at gmail dot com) #ifndef MUDUO_BASE_WEAKCALLBACK_H #define MUDUO_BASE_WEAKCALLBACK_H #include \u0026lt;functional\u0026gt; #include \u0026lt;memory\u0026gt; namespace muduo { // A barely usable WeakCallback template\u0026lt;typename CLASS, typename... ARGS\u0026gt; class WeakCallback { public: WeakCallback(const std::weak_ptr\u0026lt;CLASS\u0026gt;\u0026amp; object, const std::function\u0026lt;void (CLASS*, ARGS...)\u0026gt;\u0026amp; function) : object_(object), function_(function) { } // Default dtor, copy ctor and assignment are okay void operator()(ARGS\u0026amp;\u0026amp;... args) const { std::shared_ptr\u0026lt;CLASS\u0026gt; ptr(object_.lock()); if (ptr) { function_(ptr.get(), std::forward\u0026lt;ARGS\u0026gt;(args)...); } } private: std::weak_ptr\u0026lt;CLASS\u0026gt; object_; std::function\u0026lt;void (CLASS*, ARGS...)\u0026gt; function_; }; template\u0026lt;typename CLASS, typename... ARGS\u0026gt; WeakCallback\u0026lt;CLASS, ARGS...\u0026gt; makeWeakCallback(const std::shared_ptr\u0026lt;CLASS\u0026gt;\u0026amp; object, void (CLASS::*function)(ARGS...)) { return WeakCallback\u0026lt;CLASS, ARGS...\u0026gt;(object, function); } template\u0026lt;typename CLASS, typename... ARGS\u0026gt; WeakCallback\u0026lt;CLASS, ARGS...\u0026gt; makeWeakCallback(const std::shared_ptr\u0026lt;CLASS\u0026gt;\u0026amp; object, void (CLASS::*function)(ARGS...) const) { return WeakCallback\u0026lt;CLASS, ARGS...\u0026gt;(object, function); } } #endif 在 C++ 中替换 Observer 可以用 Signal/Slots 方式，指完全靠标准库实现的 thread safe、race condition free、thread contention free 的 Signal/Slots\n特性 核心要求 实现技术（C++ 标准库） Thread Safe 多线程并发并发调用「绑定槽函数」「触发信号」「解绑绑槽函数」时，无内存访问错误（如野指针、数据越界）。 1. std::atomic：原子管理槽函数列表的头指针及节点状态（is_valid）；\n2. 无锁单向链表：节点通过原子指针（std::atomic\u0026lt;Node*\u0026gt;）链接，避免指针访问冲突。 Race Condition Free 多线程操作共享数据（如槽函数列表）时，通过原子操作或无锁设计，确保操作结果唯一且可预测（无“读-写”“写-写”冲突）。 1. CAS 操作（std::atomic::compare_exchange_weak）：原子替换头节点，避免并发修改冲突；\n2. 快照遍历：触发信号时加载头节点快照，避免遍历中受其他线程更新影响。 Thread Contention Free 线程操作时无需等待其他线程释放锁（无阻塞），即所有共享操作通过原子指令完成，无锁竞争开销。 1. 完全无锁设计：摒弃 std::mutex 等锁机制，所有共享操作依赖用户态原子指令；\n2. 轻量级重试：CAS 操作失败时仅重试，无内核态线程切换开销。 一对多回调：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #ifndef MUDUO_BASE_SIGNALSLOTTRIVIAL_H #define MUDUO_BASE_SIGNALSLOTTRIVIAL_H #include \u0026lt;memory\u0026gt; #include \u0026lt;vector\u0026gt; template\u0026lt;typename Signature\u0026gt; class SignalTrivial; template \u0026lt;typename RET, typename... ARGS\u0026gt; class SignalTrivial\u0026lt;RET(ARGS...)\u0026gt; { public: typedef std::function\u0026lt;void (ARGS...)\u0026gt; Functor; void connect(Functor\u0026amp;\u0026amp; func) { functors_.push_back(std::forward\u0026lt;Functor\u0026gt;(func)); } void call(ARGS\u0026amp;\u0026amp;... args) { // gcc 4.6 supports //for (const Functor\u0026amp; f: functors_) typename std::vector\u0026lt;Functor\u0026gt;::iterator it = functors_.begin(); for (; it != functors_.end(); ++it) { (*it)(args...); } } private: std::vector\u0026lt;Functor\u0026gt; functors_; }; #endif // MUDUO_BASE_SIGNALSLOTTRIVIAL_H thread safe 实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 #ifndef MUDUO_BASE_SIGNALSLOT_H #define MUDUO_BASE_SIGNALSLOT_H #include \u0026#34;Mutex.h\u0026#34; #include \u0026lt;boost/function.hpp\u0026gt; #include \u0026lt;boost/noncopyable.hpp\u0026gt; #include \u0026lt;boost/shared_ptr.hpp\u0026gt; #include \u0026lt;boost/weak_ptr.hpp\u0026gt; #include \u0026lt;vector\u0026gt; namespace muduo { namespace detail { template\u0026lt;typename Callback\u0026gt; struct SlotImpl; template\u0026lt;typename Callback\u0026gt; struct SignalImpl : boost::noncopyable { typedef std::vector\u0026lt;boost::weak_ptr\u0026lt;SlotImpl\u0026lt;Callback\u0026gt; \u0026gt; \u0026gt; SlotList; SignalImpl() : slots_(new SlotList) { } void copyOnWrite() { mutex_.assertLocked(); if (!slots_.unique()) { slots_.reset(new SlotList(*slots_)); } assert(slots_.unique()); } void clean() { MutexLockGuard lock(mutex_); copyOnWrite(); SlotList\u0026amp; list(*slots_); typename SlotList::iterator it(list.begin()); while (it != list.end()) { if (it-\u0026gt;expired()) { it = list.erase(it); } else { ++it; } } } MutexLock mutex_; boost::shared_ptr\u0026lt;SlotList\u0026gt; slots_; }; template\u0026lt;typename Callback\u0026gt; struct SlotImpl : boost::noncopyable { typedef SignalImpl\u0026lt;Callback\u0026gt; Data; SlotImpl(const boost::shared_ptr\u0026lt;Data\u0026gt;\u0026amp; data, Callback\u0026amp;\u0026amp; cb) : data_(data), cb_(cb), tie_(), tied_(false) { } SlotImpl(const boost::shared_ptr\u0026lt;Data\u0026gt;\u0026amp; data, Callback\u0026amp;\u0026amp; cb, const boost::shared_ptr\u0026lt;void\u0026gt;\u0026amp; tie) : data_(data), cb_(cb), tie_(tie), tied_(true) { } ~SlotImpl() { boost::shared_ptr\u0026lt;Data\u0026gt; data(data_.lock()); if (data) { data-\u0026gt;clean(); } } boost::weak_ptr\u0026lt;Data\u0026gt; data_; Callback cb_; boost::weak_ptr\u0026lt;void\u0026gt; tie_; bool tied_; }; } /// This is the handle for a slot /// /// The slot will remain connected to the signal fot the life time of the /// returned Slot object (and its copies). typedef boost::shared_ptr\u0026lt;void\u0026gt; Slot; template\u0026lt;typename Signature\u0026gt; class Signal; template \u0026lt;typename RET, typename... ARGS\u0026gt; class Signal\u0026lt;RET(ARGS...)\u0026gt; : boost::noncopyable { public: typedef std::function\u0026lt;void (ARGS...)\u0026gt; Callback; typedef detail::SignalImpl\u0026lt;Callback\u0026gt; SignalImpl; typedef detail::SlotImpl\u0026lt;Callback\u0026gt; SlotImpl; Signal() : impl_(new SignalImpl) { } ~Signal() { } Slot connect(Callback\u0026amp;\u0026amp; func) { boost::shared_ptr\u0026lt;SlotImpl\u0026gt; slotImpl( new SlotImpl(impl_, std::forward\u0026lt;Callback\u0026gt;(func))); add(slotImpl); return slotImpl; } Slot connect(Callback\u0026amp;\u0026amp; func, const boost::shared_ptr\u0026lt;void\u0026gt;\u0026amp; tie) { boost::shared_ptr\u0026lt;SlotImpl\u0026gt; slotImpl(new SlotImpl(impl_, func, tie)); add(slotImpl); return slotImpl; } void call(ARGS\u0026amp;\u0026amp;... args) { SignalImpl\u0026amp; impl(*impl_); boost::shared_ptr\u0026lt;typename SignalImpl::SlotList\u0026gt; slots; { MutexLockGuard lock(impl.mutex_); slots = impl.slots_; } typename SignalImpl::SlotList\u0026amp; s(*slots); for (typename SignalImpl::SlotList::const_iterator it = s.begin(); it != s.end(); ++it) { boost::shared_ptr\u0026lt;SlotImpl\u0026gt; slotImpl = it-\u0026gt;lock(); if (slotImpl) { boost::shared_ptr\u0026lt;void\u0026gt; guard; if (slotImpl-\u0026gt;tied_) { guard = slotImpl-\u0026gt;tie_.lock(); if (guard) { slotImpl-\u0026gt;cb_(args...); } } else { slotImpl-\u0026gt;cb_(args...); } } } } private: void add(const boost::shared_ptr\u0026lt;SlotImpl\u0026gt;\u0026amp; slot) { SignalImpl\u0026amp; impl(*impl_); { MutexLockGuard lock(impl.mutex_); impl.copyOnWrite(); impl.slots_-\u0026gt;push_back(slot); } } const boost::shared_ptr\u0026lt;SignalImpl\u0026gt; impl_; }; } #endif // MUDUO_BASE_SIGNALSLOT_H Reference http://en.wikipedia.org/wiki/Abstraction_layer\nhttp://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD340html\nhttp://blog.csdn.net/myan/article/details/1906\nhttp://blog.csdn.net/myan/article/details/1482614\nhttp://blog.csdn.net/myan/article/details/3144661\nhttp://trac.nginx.org/nginx/ticket/134\nhttp://trac.nginx.org/nginx/ticket/135\nhttp://trac.nginx.org/nginx/ticket/162\nhttps://www.boost.org/doc/libs/latest/libs/smart_ptr/shared_ptr.htm#ThreadSafety\nhttp://blog.csdn.net/Solstice/article/details/8547547\nhttp://www.artima.com/cppsource/top_cpp_aha_moments.html\nhttp://en.wikipedia.org/wiki/Curiously_recurring_template_pattern\nhttp://blog.csdn.net/Solstice/article/details/5238671\nhttp://files.cppblog.com/Solstice/dtor_meets_mt.pdf\nhttps://blog.csdn.net/Solstice/article/details/5950190\nhttp://en.wikipedia.org/wiki/Reinventing_the_wheel\nhttps://blog.csdn.net/ilvu999/article/details/8095009?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-8095009-blog-5950190.235^v43^pc_blog_bottom_relevance_base1\u0026spm=1001.2101.3001.4242.1\u0026utm_relevant_index=3\n《Java Concurrency in Practice》 《操作系统设计与实现》《现代操作系统》《操作系统概念》任选一本 《C++ 沉思录》\n","date":"2025-10-25T20:04:14+08:00","permalink":"https://cold-rivers-snow.github.io/p/01%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","title":"01多线程下对象生命周期"},{"content":"Reference l\n","date":"2025-10-25T20:04:14+08:00","permalink":"https://cold-rivers-snow.github.io/p/%E5%BA%8F%E5%88%97%E5%8C%96/","title":"序列化"},{"content":"Hugo 简介 下载地址\nhugo github\n官网\n官方文档\nGo 语言编写的静态网站生成器，构建速度快。它拥有丰富的主题和强大的功能。\nextend 是模板继承的核心，通过 “父模板定义结构 + 子模板填充内容” 实现复用，适合统一布局的页面。 非 extend 模板是独立的，通过 partial 或 template 手动组合，适合灵活的片段复用或独立页面。 这里下载带有 extend 的安装包 如：hugo_extended_0.151.2_windows-amd64.zip\n下载下来只有一个安装包二进制文件，README.md hugo 简介，LICENSE 协议\n创建博客文件，用于存放博客内容\n1 .\\hugo.exe new site hjxblog Hugo 目录结构 官方目录说明\n默认生成的目录\n1 2 3 4 5 6 7 8 9 10 11 12 . ├── archetypes │ └── default.md ├── assets ├── content ├── data ├── i18n ├── layouts ├── static ├── resources ├── themes └── config.toml 文件名称 简要说明 archetypes 该文件夹主要用来存储博客生成的模板文件，初次使用只有一个default.md，可以根据个人的主题配置添加自定义头部信息 assets 该文件夹主要用于保存博客样式css和js文件，通过资源观点传递的全局资源 content 保存个人博客所有内容 data 保存生成站点时候所需要的配置文件，用于增强内容、配置、本地化和导航的数据文件 i18n 多语言站点的翻译表 layouts 以为.html形式存储模板，将你博客内容呈现为静态页面，包含将内容、数据和资源转换为完整网站的模板 static 存储所有静态内容：图片、.css、.js等，当使用 Hugo 生成静态页面时，构建站点时所有内容将会被复制到 public 目录文件 themes 保存主题，可以包含一个或多个，每个主题位于自己的子目录中 hugo.toml 个人博客主题样式配置文件 启动 服务\n1 ..\\hugo.exe server -D 配置主题 Hugo 默认不带主题，因此你需要去 主题社区 下载主题，本文下载 Stack 和PaperMod 测试主题\nStack 文档\n可以直接下载 release 版本 zip 包，加压到 theme 下，或者使用 submodule 方式直接 clone\n1 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack 负责 stack 中的exampleSite样例数据中的 Content 和 hugo.yaml 复制到主文件夹中\n要修改主题，你必须将想要修改的文件复制到layouts目录下的相同路径中。\n例如，若要修改themes/hugo-theme-stack/layouts/partials/header.html文件，你需要将其复制到layouts/partials/header.html，并在那里进行修改（从主题的代码库中复制代码）。这一规则同样适用于assets和static目录。\n修改根目录下的文件，可以替换多种主题，通过 git submoudle 方式可以修改主题中的内容，用于自己想要的开发。\n然后修改 hugo.yaml 中的内容\nicons 官方地址\n一篇博客文章的目录：\n1 2 3 4 5 6 content └── post └── my-first-post ├── index.md ├── image1.png └── image2.png content 内容构造格式： https://gohugo.io/content-management/sections/\n短代码嵌入视频链接或代码片段 https://stack.jimmycai.com/writing/shortcodes\n自定义菜单： https://stack.jimmycai.com/config/menu\n修改字体 下载 100font\n把字体文件放入assets/font下\n将以下代码修改并复制到layouts/partials/footer/custom.html`文件中(文件不存在就自己创建)\n- **字体名**：给字体命名一个别名，随便填写就好，保持统一就行 - **字体文件名**：字体文件的全名，带后缀名的，也就是 **xxx.ttf** 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;ChillKai\u0026#39;; src: url({{ (resources.Get \u0026#34;font/ChillKai.ttf\u0026#34;).Permalink }}) format(\u0026#39;truetype\u0026#39;); } :root { --base-font-family: \u0026#39;ChillKai\u0026#39;; --code-font-family: \u0026#39;ChillKai\u0026#39;; } \u0026lt;/style\u0026gt; eye https://letere-gzj.github.io/hugo-stack/p/hugo/view-count/\n友链、归档多列显示 修改assets/scss/custom.scss`文件(不存在则自行创建)，引入以下css样式代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @media (min-width: 1024px) { .article-list--compact { display: grid; // 目前是两列，如需三列，则后面再加一个1fr，以此类推 grid-template-columns: 1fr 1fr; background: none; box-shadow: none; gap: 1rem; article { background: var(--card-background); border: none; box-shadow: var(--shadow-l2); margin-bottom: 8px; margin-right: 8px; border-radius: 16px; } } } 文章目录折叠\u0026amp;展开 将以下代码复制到layouts/partials/footer/custom.html文件中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;style\u0026gt; #TableOfContents \u0026gt; ul, ol { ul, ol { display: none; } .open { display: block; } } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; function initTocHide() { // 判断是否存在文章目录 let toc = document.querySelector(\u0026#34;.widget--toc\u0026#34;); if (!toc) { return; } // 监听滚动 window.addEventListener(\u0026#39;scroll\u0026#39;, function() { //清除class值 let openUl = document.querySelectorAll(\u0026#34;.open\u0026#34;); if (openUl.length \u0026gt; 0) { openUl.forEach((ul) =\u0026gt; { ul.classList.remove(\u0026#34;open\u0026#34;) }) } // 获取active-class let currentLi = document.querySelector(\u0026#34;.active-class\u0026#34;); if (!currentLi) { return } // 展示子ul if (currentLi.children.length \u0026gt; 1) { currentLi.children[1].classList.add(\u0026#34;open\u0026#34;) } // 展示父ul let ul = currentLi.parentElement; do { ul.classList.add(\u0026#34;open\u0026#34;); ul = ul.parentElement.parentElement } while (ul !== undefined \u0026amp;\u0026amp; (ul.localName === \u0026#39;ul\u0026#39; || ul.localName === \u0026#39;ol\u0026#39;)) }); } initTocHide() \u0026lt;/script\u0026gt; 返回顶页按钮 https://icon-icons.com/zh/\n准备一张返回顶部图片，放到assets/icons`文件夹下\n将以下代码复制到layouts/partials/footer/custom.html`文件中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;style\u0026gt; #backTopBtn { display: none; position: fixed; bottom: 30px; z-index: 99; cursor: pointer; width: 30px; height: 30px; background-image: url({{ (resources.Get \u0026#34;icons/backTop.svg\u0026#34;).Permalink }}); } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; /** * 滚动回顶部初始化 */ function initScrollTop() { let rightSideBar = document.querySelector(\u0026#34;.right-sidebar\u0026#34;); if (!rightSideBar) { return; } // 添加返回顶部按钮到右侧边栏 let btn = document.createElement(\u0026#34;div\u0026#34;); btn.id = \u0026#34;backTopBtn\u0026#34;; btn.onclick = backToTop rightSideBar.appendChild(btn) // 滚动监听 window.onscroll = function() { // 当网页向下滑动 20px 出现\u0026#34;返回顶部\u0026#34; 按钮 if (document.body.scrollTop \u0026gt; 20 || document.documentElement.scrollTop \u0026gt; 20) { btn.style.display = \u0026#34;block\u0026#34;; } else { btn.style.display = \u0026#34;none\u0026#34;; } }; } /** * 返回顶部 */ function backToTop(){ window.scrollTo({ top: 0, behavior: \u0026#34;smooth\u0026#34; }) } initScrollTop(); \u0026lt;/script\u0026gt; 自定义MD引用块颜色模板 创建文件layouts/_default/_markup/render-blockquote-alert.html`，并将以下代码复制进去\n1 2 3 \u0026lt;blockquote class=\u0026#34;alert alert-{{ .AlertType }}\u0026#34;\u0026gt; {{ .Text | safeHTML -}} \u0026lt;/blockquote\u0026gt; 将以下代码复制进assets/scss/custom.scss`文件中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 [data-scheme=\u0026#34;light\u0026#34;] { .alert-note { --card-separator-color: #65bbee; --blockquote-background-color: #e7f2fa; } .alert-tip { --card-separator-color: #55aa55; --blockquote-background-color: #eeffee; } .alert-warn { --card-separator-color: #ffbb78; --blockquote-background-color: #ffeecc; } .alert-error { --card-separator-color: #cc3334; --blockquote-background-color: #ffeeef; } } [data-scheme=\u0026#34;dark\u0026#34;] { .alert-note { --card-separator-color: #006699; --blockquote-background-color: #002234; } .alert-tip { --card-separator-color: #336733; --blockquote-background-color: #112310; } .alert-warn { --card-separator-color: #aa5501; --blockquote-background-color: #452300; } .alert-error { --card-separator-color: #880000; --blockquote-background-color: #450000; } } 使用方法\n可选项：NOTE | TIP | WARN | ERROR 可仿照上面css写法，自行添加新的css样式，来实现更多的可选项 1 2 \u0026gt; [!NOTE] \u0026gt; 这是markdown的引用块语法 代码块过长折叠\u0026amp;展开 准备一张向下展开图片(Ctrl+S保存)，放到assets/icons`目录下\n将以下代码复制进layouts/partials/footer/custom.html`\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \u0026lt;style\u0026gt; .highlight { /* 你可以根据需要调整这个高度 */ max-height: 400px; overflow: hidden; } .code-show { max-height: none !important; } .code-more-box { width: 100%; padding-top: 78px; background-image: -webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0)), to(#fff)); position: absolute; left: 0; right: 0; bottom: 0; z-index: 1; } .code-more-btn { display: block; margin: auto; width: 44px; height: 22px; background: #f0f0f5; border-top-left-radius: 8px; border-top-right-radius: 8px; padding-top: 6px; cursor: pointer; } .code-more-img { cursor: pointer !important; display: block; margin: auto; width: 22px; height: 16px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; function initCodeMoreBox() { let codeBlocks = document.querySelectorAll(\u0026#34;.highlight\u0026#34;); if (!codeBlocks) { return; } codeBlocks.forEach(codeBlock =\u0026gt; { // 校验是否overflow if (codeBlock.scrollHeight \u0026lt;= codeBlock.clientHeight) { return; } // 元素初始化 // codeMoreBox let codeMoreBox = document.createElement(\u0026#39;div\u0026#39;); codeMoreBox.classList.add(\u0026#39;code-more-box\u0026#39;); // codeMoreBtn let codeMoreBtn = document.createElement(\u0026#39;span\u0026#39;); codeMoreBtn.classList.add(\u0026#39;code-more-btn\u0026#39;); codeMoreBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { codeBlock.classList.add(\u0026#39;code-show\u0026#39;); codeMoreBox.style.display = \u0026#39;none\u0026#39;; // 触发resize事件，重新计算目录位置 window.dispatchEvent(new Event(\u0026#39;resize\u0026#39;)) }) // img let img = document.createElement(\u0026#39;img\u0026#39;); img.classList.add(\u0026#39;code-more-img\u0026#39;); img.src = {{ (resources.Get \u0026#34;icons/codeMore.png\u0026#34;).Permalink }} // 元素添加 codeMoreBtn.appendChild(img); codeMoreBox.appendChild(codeMoreBtn); codeBlock.appendChild(codeMoreBox) }) } initCodeMoreBox(); \u0026lt;/script\u0026gt; 加入音乐 [Aplayer官方文档](https://aplayer.js.org/#/zh-Hans/)\n查看官方文档，引入对应的脚本，css到layouts\\partials\\footer\\custom.html`中，页面最下面就会出现音乐播放器\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;aplayer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const ap = new APlayer({ container: document.getElementById(\u0026#39;aplayer\u0026#39;), audio: [] }); \u0026lt;/script\u0026gt; 修改 ap对象 配置，改成吸底模式\n1 2 3 4 5 const ap = new APlayer({ ..., // 吸底模式 fixed: true }); 填写 audio 数组，引入歌曲，封面和歌词\nlrcType 的值具体看【文档】https://aplayer.js.org/#/zh-Hans/?id=%E6%AD%8C%E8%AF%8D 歌曲，封面，歌词支持远程链接 or 本地路径 若想通过本地路径引入，请将资源文件放在static文件夹下，通过hugo方法{{ .Site.Home.Permalink }}，获取网站主路径来拼接文件路径，进行引入 加入评论 giscus https://giscus.app/zh-CN 进入官网，仓库开启条件\nsetting-\u0026gt;general-\u0026gt;feature 选择 Discussions\n进入 https://github.com/apps/giscus 安装\n将生成的 html 记住，将 theme /stack 中的搜giscus.html 将其放入到对应的根目录下\n配置 Hugo\n修改配置文件\n非 yaml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 [params.giscus] enable = true repo = \u0026#34;cold-rivers-snow/cold-rivers-snow.github.io\u0026#34; # 替换为您的 GitHub 仓库 repoId = \u0026#34;R_kgDOJpljfQ\u0026#34; # 替换为您的仓库 ID category = \u0026#34;General\u0026#34; # 评论分类 categoryId = \u0026#34;DIC_kwDOJpljfc4CoOtn\u0026#34; # 替换为您的分类 ID mapping = \u0026#34;title\u0026#34; # 使用文章标题作为映射 strict = 0 # 严格模式 reactionsEnabled = 1 # 启用反应 emitMetadata = 0 # 不发送元数据 inputPosition = \u0026#34;top\u0026#34; # 评论框位置 theme = \u0026#34;preferred_color_scheme\u0026#34; # 跟随系统主题 lang = \u0026#34;zh-CN\u0026#34; # 语言设置 loading = \u0026#34;lazy\u0026#34; # 懒加载 yaml：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 comments: enabled: true # giscus, disqus, utterances, waline, artalk, twikoo system: \u0026#34;giscus\u0026#34; giscus: repo: \u0026#34;data-repo\u0026#34; repoId: \u0026#34;data-repo-id\u0026#34; category: \u0026#34;Announcements\u0026#34; categoryId: \u0026#34;data-category-id\u0026#34; mapping: \u0026#34;pathname\u0026#34; strict: \u0026#34;0\u0026#34; reactionsEnabled: \u0026#34;1\u0026#34; emitMetadata: \u0026#34;0\u0026#34; inputPosition: \u0026#34;bottom\u0026#34; theme: \u0026#34;preferred_color_scheme\u0026#34; lang: \u0026#34;en\u0026#34; repoid 获取 https://api.github.com/repos/用户名/仓库名\n最终你会在文章底部看到这样一个界面：\npjax 修复\n修改layouts/partials/comments/include.html，添加一个元素标识，方便判断文章是否开启了评论\n1 2 3 4 {{ if .Site.Params.comments.enabled }} ... \u0026lt;div class=\u0026#34;comment\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; {{ end }} 结合giscus文件，layouts/partials/comments/provider/giscus.html 添加以下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 {{- with .Site.Params.comments.giscus -}} \u0026lt;div class=\u0026#34;js-Pjax\u0026#34;\u0026gt; \u0026lt;script\u0026gt; (function () { // 判断当前是否有文章评论标识 let comment = document.querySelector(\u0026#34;.comment\u0026#34;); if (!comment) { return } let script = document.createElement(\u0026#39;script\u0026#39;); // 将对应评论的脚本内容填进去 script.setAttribute(\u0026#39;src\u0026#39;, \u0026#39;https://giscus.app/client.js\u0026#39;); script.setAttribute(\u0026#39;data-repo\u0026#39;, \u0026#39;{{- .repo -}}\u0026#39;); // ...以此类推 script.async = true; // 寻找合适的元素，添加脚本进去(在页脚前将评论脚本插入) document.querySelector(\u0026#39;.site-footer\u0026#39;).before(script) })(document); \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt; {{- end -}} 在layouts/partials/footer/custom.html，引入以下代码\n1 2 3 4 5 6 7 8 \u0026lt;script\u0026gt; var pjax = new Pjax({ selectors: [ ... \u0026#34;.js-Pjax\u0026#34; ] }) \u0026lt;/script\u0026gt; github 部署 创建仓库，名为 自己用户名.github.io\n生成 token，在用户的 setting-\u0026gt;Developer Settings-\u0026gt;Personal access tokens，创建一个token(classic)\ntoken选择永不过期，并勾选 repo 和 workflow 选项\n为保证安全，将生成的token，保存的仓库的变量中，前往 项目的Settings -\u0026gt; Secrets and variables -\u0026gt; Actions中设置，配置环境变量\n创建一个.github/workflows/xxxx.yaml`文件，将以下内容复制进去，想具体了解更多，可查看【Github Action文档】\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} EXTERNAL_REPOSITORY: 你的github名/你的仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy 建.gitignore`文件，来避免提交不必要的文件\n1 2 3 4 5 6 7 # 自动生成的文件 public resources .hugo_build.lock # hugo命令 hugo.exe 查看仓库，Action\n搭建图床 picgo picgo的下载 首先在浏览器内直接搜索picgo\nGitHub下载链接\npicgo的配置 插件设置搜索 bilibil 或 bilibili github 地址\n点击安装，依赖，需要提前安装 nodejs\n登录 b 站 f12 获取以下值\n将SESSDATA复制到picgo的SESSDATA中；将bili_jct复制到picgo的csrf中\n配置默认远程服务\ntypora 文本用法 引入外部内容\n学如逆水行舟，不进则退。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstddef\u0026gt; // 用于size_t #include \u0026lt;stdexcept\u0026gt; // 用于异常处理 template\u0026lt;typename T\u0026gt; struct Array { public: // 迭代器类型定义（模仿vector的迭代器行为） using iterator = T*; using const_iterator = const T*; // 默认构造函数：初始容量为1 Array() : _data(new T[1]), _size(0), _cap(1) {} // 带初始容量的构造函数 explicit Array(size_t cap) : _cap(cap), _size(0) { if (cap == 0) { throw std::invalid_argument(\u0026#34;Capacity cannot be zero\u0026#34;); } _data = new T[cap]; } // 拷贝构造函数（深拷贝，避免浅拷贝问题） Array(const Array\u0026amp; other) : _size(other._size), _cap(other._cap) { _data = new T[_cap]; for (size_t i = 0; i \u0026lt; _size; ++i) { _data[i] = other._data[i]; } } // 赋值运算符重载（深拷贝） Array\u0026amp; operator=(const Array\u0026amp; other) { if (this != \u0026amp;other) { // 避免自赋值 delete[] _data; // 释放原有资源 _size = other._size; _cap = other._cap; _data = new T[_cap]; for (size_t i = 0; i \u0026lt; _size; ++i) { _data[i] = other._data[i]; } } return *this; } // 析构函数：释放动态内存 ~Array() { delete[] _data; _data = nullptr; // 避免野指针 } // 获取元素个数 size_t size() const { return _size; } // 获取容量 size_t capacity() const { return _cap; } // 判断是否为空 bool empty() const { return _size == 0; } // 尾插元素 void push_back(const T\u0026amp; val) { if (_size \u0026gt;= _cap) { reserve(2 * _cap); // 容量不足时扩容为原来的2倍 } _data[_size++] = val; } // 尾删元素 void pop_back() { if (empty()) { throw std::out_of_range(\u0026#34;Array is empty, cannot pop back\u0026#34;); } --_size; // 逻辑删除（对于基础类型足够，复杂类型需调用析构） } // 访问指定索引元素（带越界检查） T\u0026amp; operator[](size_t index) { if (index \u0026gt;= _size) { throw std::out_of_range(\u0026#34;Index out of range\u0026#34;); } return _data[index]; } const T\u0026amp; operator[](size_t index) const { if (index \u0026gt;= _size) { throw std::out_of_range(\u0026#34;Index out of range\u0026#34;); } return _data[index]; } // 预留容量（仅扩容，不改变元素个数） void reserve(size_t new_cap) { if (new_cap \u0026lt;= _cap) return; // 新容量小于等于当前容量则不操作 T* new_data = new T[new_cap]; for (size_t i = 0; i \u0026lt; _size; ++i) { new_data[i] = _data[i]; } delete[] _data; _data = new_data; _cap = new_cap; } // 调整元素个数（可缩小或扩容，扩容时用默认值填充） void resize(size_t new_size) { if (new_size \u0026gt; _cap) { reserve(new_size); // 容量不足则扩容 } _size = new_size; // 直接调整大小（缩小为逻辑删除，扩容为默认值填充） } // 插入元素到指定位置 void insert(iterator pos, const T\u0026amp; val) { if (pos \u0026lt; begin() || pos \u0026gt; end()) { throw std::out_of_range(\u0026#34;Insert position out of range\u0026#34;); } if (_size \u0026gt;= _cap) { reserve(2 * _cap); // 扩容 pos = _data + (pos - begin()); // 扩容后迭代器失效，重新计算位置 } // 从插入位置开始后移元素 for (iterator it = end(); it \u0026gt; pos; --it) { *it = *(it - 1); } *pos = val; ++_size; } // 删除指定位置元素 void erase(iterator pos) { if (pos \u0026lt; begin() || pos \u0026gt;= end()) { throw std::out_of_range(\u0026#34;Erase position out of range\u0026#34;); } // 从删除位置后一个元素开始前移 for (iterator it = pos; it \u0026lt; end() - 1; ++it) { *it = *(it + 1); } --_size; } // 迭代器相关函数（模仿vector的迭代器接口） iterator begin() { return _data; } iterator end() { return _data + _size; } const_iterator begin() const { return _data; } const_iterator end() const { return _data + _size; } private: T* _data; // 存储元素的动态数组 size_t _size; // 当前元素个数（使用size_t更符合容器设计习惯） size_t _cap; // 容量 }; // 测试函数 int main() { try { // 测试构造和push_back Array\u0026lt;int\u0026gt; arr; arr.push_back(10); arr.push_back(20); arr.push_back(30); std::cout \u0026lt;\u0026lt; \u0026#34;Size: \u0026#34; \u0026lt;\u0026lt; arr.size() \u0026lt;\u0026lt; \u0026#34;, Capacity: \u0026#34; \u0026lt;\u0026lt; arr.capacity() \u0026lt;\u0026lt; std::endl; // 3,4 // 测试访问元素 for (size_t i = 0; i \u0026lt; arr.size(); ++i) { std::cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 10 20 30 } std::cout \u0026lt;\u0026lt; std::endl; // 测试迭代器 for (auto it = arr.begin(); it != arr.end(); ++it) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 10 20 30 } std::cout \u0026lt;\u0026lt; std::endl; // 测试插入 arr.insert(arr.begin() + 1, 15); std::cout \u0026lt;\u0026lt; \u0026#34;After insert: \u0026#34;; for (int val : arr) { // 范围for循环依赖迭代器 std::cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 10 15 20 30 } std::cout \u0026lt;\u0026lt; std::endl; // 测试删除 arr.erase(arr.begin() + 2); std::cout \u0026lt;\u0026lt; \u0026#34;After erase: \u0026#34;; for (int val : arr) { std::cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 10 15 30 } std::cout \u0026lt;\u0026lt; std::endl; // 测试拷贝构造 Array\u0026lt;int\u0026gt; arr2 = arr; arr2.push_back(40); std::cout \u0026lt;\u0026lt; \u0026#34;arr2: \u0026#34;; for (int val : arr2) { std::cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 10 15 30 40 } std::cout \u0026lt;\u0026lt; std::endl; } catch (const std::exception\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } return 0; } 短代码支持语雀导出得图片链接\n短代码支持 github 中代码文件引用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // Copyright 2024 The Hugo Authors. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/gohugoio/hugo/commands\u0026#34; ) func main() { log.SetFlags(0) err := commands.Execute(os.Args[1:]) if err != nil { log.Fatalf(\u0026#34;Error: %s\u0026#34;, err) } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 // -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:nil -*- // vim: ts=8 sw=2 sts=2 expandtab ft=cpp /* * Ceph - scalable distributed file system * * Copyright (C) 2022 New Dream Network * * This is free software; you can redistribute it and/or * modify it under the terms of the GNU Lesser General Public * License version 2.1, as published by the Free Software * Foundation. See file COPYING. * */ #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026#34;include/rados/librgw.h\u0026#34; #include \u0026#34;include/str_list.h\u0026#34; #include \u0026#34;common/ceph_argparse.h\u0026#34; #include \u0026#34;common/ceph_context.h\u0026#34; #include \u0026#34;common/dout.h\u0026#34; #include \u0026#34;rgw_lib.h\u0026#34; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;mutex\u0026gt; #define dout_subsys ceph_subsys_rgw namespace rgw { bool global_stop = false; static std::mutex librgw_mtx; static RGWLib rgwlib; } // namespace rgw extern \u0026#34;C\u0026#34; { int librgw_create(librgw_t* rgw, int argc, char **argv) { using namespace rgw; int rc = -EINVAL; g_rgwlib = \u0026amp;rgwlib; if (! g_ceph_context) { std::lock_guard\u0026lt;std::mutex\u0026gt; lg(librgw_mtx); if (! g_ceph_context) { std::vector\u0026lt;std::string\u0026gt; spl_args; // last non-0 argument will be split and consumed if (argc \u0026gt; 1) { const std::string spl_arg{argv[(--argc)]}; get_str_vec(spl_arg, \u0026#34; \\t\u0026#34;, spl_args); } auto args = argv_to_vec(argc, argv); // append split args, if any for (const auto\u0026amp; elt : spl_args) { args.push_back(elt.c_str()); } rc = rgwlib.init(args); } } *rgw = g_ceph_context-\u0026gt;get(); return rc; } void librgw_shutdown(librgw_t rgw) { using namespace rgw; CephContext* cct = static_cast\u0026lt;CephContext*\u0026gt;(rgw); rgwlib.stop(); dout(1) \u0026lt;\u0026lt; \u0026#34;final shutdown\u0026#34; \u0026lt;\u0026lt; dendl; cct-\u0026gt;put(); } } /* extern \u0026#34;C\u0026#34; */ 关于 github.com 和 raw.githubusercontent.com 区别的比较：\n特性 github.com raw.githubusercontent.com 主要目的 提供 Web 界面、用户界面和代码仓库管理。 提供 原始、未经处理的文件内容（Raw Content）。 返回内容 HTML 页面（包含导航栏、按钮、评论等）。 文件的纯文本（或二进制）内容，没有 HTML 包装。 Content-Type text/html 通常是 text/plain 或文件对应的 Mime-Type。 典型 URL 路径 .../user/repo/blob/main/file.go .../user/repo/main/file.go 使用场景 人类用户通过浏览器进行代码审查、提交、Issue 跟踪等操作。 机器或程序（如 Hugo、脚本）需要下载、读取、或直接使用文件内容。 文件加载 文件内容被嵌入到网页的 HTML 结构中。 文件内容作为独立的数据流直接传输。 引入外部链接\n搜索 Reference https://www.bilibili.com/video/BV1bovfeaEtQ?spm_id_from=333.788.videopod.episodes\u0026amp;vd_source=3cc5c63659274d24dd07e99dc80bc98d\nhttps://letere-gzj.github.io/hugo-stack/p/hugo/custom-blog/\nhttps://huxinme.top/posts/blog/hugo-blog/\nhttps://the-oone.github.io/p/github-pages-hugo-%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/\nhttps://www.github-zh.com/getting-started/github-pages\nhttps://ainfinitythecoder.cn/zh/posts/wondering/setup-a-personal-blog/\nhttps://blog.jaxiu.cn/blog/2025-07/%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-github-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/\nhttps://gohugo.io/documentation/\nhttps://letere-gzj.github.io/hugo-stack/p/hugo/custom-stack-theme/#2-%E4%BF%AE%E6%94%B9%E9%BC%A0%E6%A0%87%E6%A0%B7%E5%BC%8F\nhttps://letere-gzj.github.io/hugo-stack/archives/\nhttps://github.com/JanePHPDev/TurboFeLy 替代 pjax\nhttps://www.heyjude.blog/zh-cn/posts/giscus-comments-hugo/\nhttps://www.cnblogs.com/AxonoSensei/p/19052814\n","date":"2025-10-21T20:04:14+08:00","permalink":"https://cold-rivers-snow.github.io/p/%E5%AF%92%E6%B1%9F%E9%9B%AA%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","title":"寒江雪的博客搭建"}]