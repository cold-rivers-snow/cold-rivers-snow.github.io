---
title: "01多线程下对象生命周期"
# date: 2025-10-21T20:04:14+08:00
# lastmod: 2025-10-21T20:04:14+08:00
# {{ .Lastmod | time.Format "2025-10-25" }}
author: ["寒江雪"]

categories:
- muduo
- 多线程
- linux
- c++

description: "" # 文章描述，与搜索优化相关
summary: "muduo 文章阅读" # 文章简单描述，会展示在主页
draft: false # 是否为草稿
math: true # 启用/禁用KaTeX渲染。
comments: true
image:  # 文章图片
toc: true # 目录 默认值 .Site.Params.Article.toc， bool 类型，至少有一个标题才会显示
showToc: true # 显示目录
TocOpen: true # 自动展开目录
readingTime: true # 显示阅读时间
autonumbering: true # 目录自动编号
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
searchHidden: false # 该页面可以被搜索到
showbreadcrumbs: true #顶部显示当前路径
mermaid: true # 是否流程图渲染
style:  # 用于文章页面中出现的分类术语徽章的额外CSS样式。用于列表页面，目前仅支持background和color
    background: "white"
    color: "black"
license: 
    enabled: false
    default: Licensed under CC BY-NC-SA 4.0
cover:   # 封面的详细信息
    image: ""  # 封面图片
    caption: "" # 封面图片下方显示的文字说明或标题
    alt: "" # 封面图片提供替代文本
    relative: false # 所提供的图片路径是否为相对路径
---

## 多线程下析构函数

### race condition

- 析构对象时，是否有其他线程正在执行这个对象的其他成员函数等操作。
- 对象执行操作，没有其他线程析构。
- 对象操作或者析构之前，确定对象存活，没有其他线程操作。

shared_ptr 解决。

### 线程安全定义

一个线程安全的 class 满足的三个条件：

1. 多线程同时访问，表现正确
2. 不管操作系统如何调度、线程执行顺序如何
3. 调用端代码无须额外的同步或其他协调动作

根据此要求，c++ 标准库中的 string、vector、map 等类型都不满足要求，需要加锁使用。

### MutexLock 和 MutexLockGuard

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/Mutex.h" "c++" "linenos=true" >}}

| 特性          | 重入锁（递归锁）| 不可重入锁（默认） |
|---------------|------------------|--------------------|
| 同一线程加锁次数 | 允许多次加锁    | 仅允许一次加锁     |
| 死锁风险      | 需保证解锁次数与加锁次数一致，否则仍会死锁 | 同一线程多次加锁直接死锁 |
| 创建方式      | 需显式设置属性   | 默认即支持         |
| 性能开销      | 略高（需维护锁的递归计数） | 开销低             |
| 适用场景      | 递归函数、同一线程多步骤加锁 | 简单互斥场景，避免逻辑错误 |

c++11 实现的自旋锁，也是不可重入的

{{< remotecode "https://raw.githubusercontent.com/chronolaw/cpp_study/master/section5/SpinLock.hpp" "c++" "linenos=true" >}}

### 锁的分类与核心特性

#### 1. 按「线程等待机制」分类（自旋锁所属维度）

| 锁类型       | 核心特征（等待机制）                          | 适用场景                                  | 典型示例                                  |
|--------------|---------------------------------------------|-------------------------------------------|-------------------------------------------|
| **自旋锁**   | 忙等待：获取锁失败时，线程循环重试（不挂起），通过 `yield()` 让出 CPU，但保持运行态。 | 锁持有时间极短（微秒级），避免线程阻塞/唤醒的内核开销。 | `std::atomic_flag` 实现的自旋锁、Linux 内核 `spinlock_t`。 |
| **互斥锁**   | 阻塞等待：获取锁失败时，线程被内核挂起（阻塞态），锁释放时由内核唤醒。 | 锁持有时间较长（毫秒级），避免自旋导致的 CPU 空耗。 | `std::mutex`、`pthread_mutex_t`（默认类型）。 |

#### 2. 按「重入性」分类

| 锁类型         | 核心特征（同一线程重复加锁）                | 典型示例                                  |
|----------------|---------------------------------------------|-------------------------------------------|
| **不可重入锁** | 同一线程对已持有的锁再次加锁会导致死锁。    | 默认 `std::mutex`、基础自旋锁实现。        |
| **可重入锁**   | 同一线程可多次加锁，需通过「线程 ID + 递归计数」实现（解锁次数需匹配）。 | `std::recursive_mutex`、`PTHREAD_MUTEX_RECURSIVE` 类型的 `pthread_mutex_t`。 |

#### 3. 按「竞争范围」分类

| 锁类型       | 核心特征（竞争资源的范围）                  | 典型示例                                  |
|--------------|---------------------------------------------|-------------------------------------------|
| **线程锁**   | 仅同一进程内的线程竞争，锁状态存储在进程地址空间（用户态）。 | `std::mutex`、自旋锁、`pthread_mutex_t`。  |
| **进程锁**   | 多进程间竞争，锁状态存储在共享资源（文件、共享内存）。 | 文件锁（`fcntl`）、System V 信号量。       |

#### 4. 按「功能特性」分类（特定场景优化）

| 锁类型           | 核心特征（功能优化）                        | 适用场景                                  | 典型示例                                  |
|------------------|---------------------------------------------|-------------------------------------------|-------------------------------------------|
| **读写锁**       | 区分读写操作：多线程同时读（共享），写操作独占（互斥）。 | 读多写少场景（如缓存、配置文件）。        | `std::shared_mutex`（C++17）、`pthread_rwlock_t`。 |
| **条件变量**     | 配合互斥锁实现「等待-通知」机制，解决盲目等待问题。 | 生产者-消费者模型、线程同步信号。          | `std::condition_variable`、`pthread_cond_t`。 |
| **信号量**       | 通过计数器控制资源访问数量（支持 N 个并发访问）。 | 限制资源并发数（如连接池、线程池）。      | `std::counting_semaphore`（C++20）、POSIX 信号量。 |
