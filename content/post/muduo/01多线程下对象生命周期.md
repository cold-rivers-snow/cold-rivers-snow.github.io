---
title: "01多线程下对象生命周期"
date: 2025-10-25T20:04:14+08:00
# lastmod: 2025-10-21T20:04:14+08:00
author: ["寒江雪"]

categories:
- muduo
- 多线程
- linux
- c++

description: "" # 文章描述，与搜索优化相关
summary: "muduo 文章阅读" # 文章简单描述，会展示在主页
draft: false # 是否为草稿
math: true # 启用/禁用KaTeX渲染。
comments: true
image:  # 文章图片
toc: true # 目录 默认值 .Site.Params.Article.toc， bool 类型，至少有一个标题才会显示
showToc: true # 显示目录
TocOpen: true # 自动展开目录
readingTime: true # 显示阅读时间
autonumbering: true # 目录自动编号
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
searchHidden: false # 该页面可以被搜索到
showbreadcrumbs: true #顶部显示当前路径
mermaid: true # 是否流程图渲染
style:  # 用于文章页面中出现的分类术语徽章的额外CSS样式。用于列表页面，目前仅支持background和color
    background: "white"
    color: "black"
license: 
    enabled: false
    default: Licensed under CC BY-NC-SA 4.0
cover:   # 封面的详细信息
    image: ""  # 封面图片
    caption: "" # 封面图片下方显示的文字说明或标题
    alt: "" # 封面图片提供替代文本
    relative: false # 所提供的图片路径是否为相对路径
---

## 多线程下析构函数

### race condition

- 析构对象时，是否有其他线程正在执行这个对象的其他成员函数等操作。
- 对象执行操作，没有其他线程析构。
- 对象操作或者析构之前，确定对象存活，没有其他线程操作。

shared_ptr 解决。

### 线程安全定义

一个线程安全的 class 满足的三个条件：

1. 多线程同时访问，表现正确
2. 不管操作系统如何调度、线程执行顺序如何
3. 调用端代码无须额外的同步或其他协调动作

根据此要求，c++ 标准库中的 string、vector、map 等类型都不满足要求，需要加锁使用。

### MutexLock 和 MutexLockGuard

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/Mutex.h" "c++" "linenos=true" >}}

| 特性          | 重入锁（递归锁）| 不可重入锁（默认） |
|---------------|------------------|--------------------|
| 同一线程加锁次数 | 允许多次加锁    | 仅允许一次加锁     |
| 死锁风险      | 需保证解锁次数与加锁次数一致，否则仍会死锁 | 同一线程多次加锁直接死锁 |
| 创建方式      | 需显式设置属性   | 默认即支持         |
| 性能开销      | 略高（需维护锁的递归计数） | 开销低             |
| 适用场景      | 递归函数、同一线程多步骤加锁 | 简单互斥场景，避免逻辑错误 |

c++11 实现的自旋锁，也是不可重入的

{{< remotecode "https://raw.githubusercontent.com/chronolaw/cpp_study/master/section5/SpinLock.hpp" "c++" "linenos=true" >}}

### 锁的分类与核心特性

#### 1. 按「线程等待机制」分类

| 锁类型       | 核心特征（等待机制）                          | 适用场景                                  | 典型示例                                  |
|--------------|---------------------------------------------|-------------------------------------------|-------------------------------------------|
| **自旋锁**   | 忙等待：获取锁失败时，线程循环重试（不挂起），通过 `yield()` 让出 CPU，但保持运行态。 | 锁持有时间极短（微秒级），避免线程阻塞/唤醒的内核开销。 | `std::atomic_flag` 实现的自旋锁、Linux 内核 `spinlock_t`。 |
| **互斥锁**   | 阻塞等待：获取锁失败时，线程被内核挂起（阻塞态），锁释放时由内核唤醒。 | 锁持有时间较长（毫秒级），避免自旋导致的 CPU 空耗。 | `std::mutex`、`pthread_mutex_t`（默认类型）。 |

#### 2. 按「重入性」分类

| 锁类型         | 核心特征（同一线程重复加锁）                | 典型示例                                  |
|----------------|---------------------------------------------|-------------------------------------------|
| **不可重入锁** | 同一线程对已持有的锁再次加锁会导致死锁。    | 默认 `std::mutex`、基础自旋锁实现。        |
| **可重入锁**   | 同一线程可多次加锁，需通过「线程 ID + 递归计数」实现（解锁次数需匹配）。 | `std::recursive_mutex`、`PTHREAD_MUTEX_RECURSIVE` 类型的 `pthread_mutex_t`。 |

#### 3. 按「竞争范围」分类

| 锁类型       | 核心特征（竞争资源的范围）                  | 典型示例                                  |
|--------------|---------------------------------------------|-------------------------------------------|
| **线程锁**   | 仅同一进程内的线程竞争，锁状态存储在进程地址空间（用户态）。 | `std::mutex`、自旋锁、`pthread_mutex_t`。  |
| **进程锁**   | 多进程间竞争，锁状态存储在共享资源（文件、共享内存）。 | 文件锁（`fcntl`）、System V 信号量。       |

#### 4. 按「功能特性」分类（特定场景优化）

| 锁类型           | 核心特征（功能优化）                        | 适用场景                                  | 典型示例                                  |
|------------------|---------------------------------------------|-------------------------------------------|-------------------------------------------|
| **读写锁**       | 区分读写操作：多线程同时读（共享），写操作独占（互斥）。 | 读多写少场景（如缓存、配置文件）。        | `std::shared_mutex`（C++17）、`pthread_rwlock_t`。 |
| **条件变量**     | 配合互斥锁实现「等待-通知」机制，解决盲目等待问题。 | 生产者-消费者模型、线程同步信号。          | `std::condition_variable`、`pthread_cond_t`。 |
| **信号量**       | 通过计数器控制资源访问数量（支持 N 个并发访问）。 | 限制资源并发数（如连接池、线程池）。      | `std::counting_semaphore`（C++20）、POSIX 信号量。 |

## 对象的创建

对象构造要做到线程安全，就不能在构造期间泄露 this 指针

- 不要再构造函数中注册任何回调
- 不要再构造函数中把 this 传递给跨线程的对象

## 对象析构

避免悬空指针和野指针

悬空指针：指向已经消毁的对象或已经回收的地址
野指针：未初始化的指针

面向对象设计中，对象的关系主要有三种：composition（组合/复合）、aggregation（聚合）、asscoiation（关联/联系）


{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/test/Observer.cc" "c++" "linenos=true" >}}

## shared_ptr 和 weak_ptr

- shared_ptr 强引用控制对象生命周期，指向的对象，直到最后一个没有析构或者reset()
- weak_ptr 弱引用不控制对象生命周期，但是知道对象是否还活着，可以提升为 shared_ptr, 提升/lock() 是线程安全的
- shared_ptr、weak_ptr 主流平台实现都没有用所，用原子能力，性能可以。
- shared_ptr、weak_ptr、scoped_ptr 都是值语义

c++ 中内存错误大致几个方面：

- 缓冲区溢出 ： 用std::vector<char>/std::string 或自己编写的 Buffer Class 做缓冲区，自动记住缓冲区长度，并通过成员函数而不是裸指针来修改缓冲区
- 悬空指针/野指针：用 shared_ptr/weak_ptr
- 重复释放：用 scoped_ptr, 只对对象析构时候释放一次
- 内存泄漏：用 scoped_ptr, 对象析构时候自动释放内存
- 不配对的 new[]/delete：把 net[]/delete 改为std::vector/scoped_array
- 内存碎片

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/test/Observer_safe.cc" "c++" "linenos=true" >}}

多线程中同时访问同一个 shared_ptr,正确的做法加锁

```cpp
MutexLock mutex;
shared_ptr<Foo> globalPtr;

void doit(const shared_ptr<Foo>& pFoo);

void read()
{
shared_ptr<Foo> ptr;
  {
    MutexLock lock(mutex);
    ptr = globalPtr;  // read globalPtr
  }
  // use ptr since here
  doit(ptr);
}
 
 //写入的时候也要加锁：
void write()
{
  shared_ptr<Foo> newptr(new Foo);
  {
    MutexLock lock(mutex);
    globalPtr = newptr;  // write to globalPtr
  } 
  // use newptr since here
  doit(newptr);
}
```

## 对象池

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/test/Factory.cc" "c++" "linenos=true" >}}

enable_shared_from_this 以派生类为模板类型实参的基类模板，继承它，this 指针变为 shared_ptr类型

shared_from_this() 不能在构造函数中调用，因为类型的构造函数中还没有交给 shared_ptr 管理生命周期

把 shared_ptr 邦（std::bind）到 boost::function 里，那么回调的时候 StockFactory 对象始终存在，是安全的，延长了对象的生命周期，使得不短于邦的 boost::function 对象。

使用 weak_ptr 邦到 boost::function 这样，对象的生命周期不会延长，然后再回调的时候尝试提升为 shared_ptr，如果提升成功，说明接受回调的对象还健在，那么执行回调，如果失败，则不处理。

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/WeakCallback.h" "c++" "linenos=true" >}}

在 C++ 中替换 Observer 可以用 Signal/Slots 方式，指完全靠标准库实现的 thread safe、race condition free、thread contention free 的 Signal/Slots

| 特性                | 核心要求                                                                 | 实现技术（C++ 标准库）                                                                 |
|---------------------|--------------------------------------------------------------------------|---------------------------------------------------------------------------------------|
| **Thread Safe**     | 多线程并发并发调用「绑定槽函数」「触发信号」「解绑绑槽函数」时，无内存访问错误（如野指针、数据越界）。 | 1. `std::atomic`：原子管理槽函数列表的头指针及节点状态（`is_valid`）；<br>2. 无锁单向链表：节点通过原子指针（`std::atomic<Node*>`）链接，避免指针访问冲突。 |
| **Race Condition Free** | 多线程操作共享数据（如槽函数列表）时，通过原子操作或无锁设计，确保操作结果唯一且可预测（无“读-写”“写-写”冲突）。 | 1. CAS 操作（`std::atomic::compare_exchange_weak`）：原子替换头节点，避免并发修改冲突；<br>2. 快照遍历：触发信号时加载头节点快照，避免遍历中受其他线程更新影响。 |
| **Thread Contention Free** | 线程操作时无需等待其他线程释放锁（无阻塞），即所有共享操作通过原子指令完成，无锁竞争开销。 | 1. 完全无锁设计：摒弃 `std::mutex` 等锁机制，所有共享操作依赖用户态原子指令；<br>2. 轻量级重试：CAS 操作失败时仅重试，无内核态线程切换开销。 |

一对多回调：

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/SignalSlotTrivial.h" "c++" "linenos=true" >}}

thread safe 实现：

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/SignalSlot.h" "c++" "linenos=true" >}}

## Reference

http://en.wikipedia.org/wiki/Abstraction_layer
http://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD340html
http://blog.csdn.net/myan/article/details/1906
http://blog.csdn.net/myan/article/details/1482614
http://blog.csdn.net/myan/article/details/3144661
http://trac.nginx.org/nginx/ticket/134
http://trac.nginx.org/nginx/ticket/135
http://trac.nginx.org/nginx/ticket/162
https://www.boost.org/doc/libs/latest/libs/smart_ptr/shared_ptr.htm#ThreadSafety
http://blog.csdn.net/solstice/article/details/8547547
http://www.artima.com/cppsource/top_cpp_aha_moments.html
http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern
http://blog.csdn.net/solstice/article/details/5238671
http://files.cppblog.com/Solstice/dtor_meets_mt.pdf
https://blog.csdn.net/Solstice/article/details/5950190
http://en.wikipedia.org/wiki/Reinventing_the_wheel
https://blog.csdn.net/ilvu999/article/details/8095009?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-8095009-blog-5950190.235^v43^pc_blog_bottom_relevance_base1&spm=1001.2101.3001.4242.1&utm_relevant_index=3
《Java Concurrency in Practice》
《操作系统设计与实现》《现代操作系统》《操作系统概念》任选一本
《C++ 沉思录》
