---
title: "02线程同步精要"
date: 2025-10-26T20:04:14+08:00
author: ["寒江雪"]

categories:
- muduo
- 多线程
- linux
- c++

description: "" # 文章描述，与搜索优化相关
summary: "muduo 文章阅读" # 文章简单描述，会展示在主页
draft: false # 是否为草稿
math: true # 启用/禁用KaTeX渲染。
comments: true
image:  # 文章图片
toc: true # 目录 默认值 .Site.Params.Article.toc， bool 类型，至少有一个标题才会显示
showToc: true # 显示目录
TocOpen: true # 自动展开目录
readingTime: true # 显示阅读时间
autonumbering: true # 目录自动编号
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
searchHidden: false # 该页面可以被搜索到
showbreadcrumbs: true #顶部显示当前路径
mermaid: true # 是否流程图渲染
style:  # 用于文章页面中出现的分类术语徽章的额外CSS样式。用于列表页面，目前仅支持background和color
    background: "white"
    color: "black"
license: 
    enabled: false
    default: Licensed under CC BY-NC-SA 4.0
cover:   # 封面的详细信息
    image: ""  # 封面图片
    caption: "" # 封面图片下方显示的文字说明或标题
    alt: "" # 封面图片提供替代文本
    relative: false # 所提供的图片路径是否为相对路径
---

并发编程有两种基本模型：

- message passing （消息传递）
- shared memory （共享内存）

分布式系统中，运行多台机器上的多个进程并发只有一种实用模型：message passing

线程同步的四项原则：

1. 首先尽量最低限度地共享对象，减少需要同步地场合。一个对象能不暴露给别地线程不要暴露；如果要暴露，优先考虑 immutable 对象，实在不行才暴露可修改地对象，并用同步措施来充分保护它。
2. 其次使用高级地并发编程构件。如 TaskQueue、Producer-Consumer Queue、CountDownLatch 等等。
3. 最后不得已必须使用同步原语时，只用非递归地互斥器和条件变量，慎用读写锁，不要用信号量。
4. 除了使用 atomic 整数之外，不自己编写 lock-free 代码，也不要用“内核级”同步原语。不凭空猜测“那种性能会更好”，比如 spin lock vs mutex.

## 互斥锁

原则：

- 使用 RAII 手法操作 mutex
- 只用不可重入锁
- 不手动 lock() unlock(),交给 RAII
- 不用跨进程地锁，进程间只用 TCP sockets。
- 必要时候可以考虑用 PTHREAD_MUTEX_ERRORCHECK 来排错。

mutex 分为递归和非递归两种，这是 POSIX 地叫法，另外名字是可重入和非可重入，这两种唯一地区别是同一个线程可以重复对 recursive mutex 加锁，但是不能重复对 non-recursive mutex 加锁。

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/test/NonRecursiveMutex_test.cc" "c++" "linenos=true" >}}

1. post() 和 traverse() 加锁都没问题
2. doit() 间接调用 post() 导致 mutex 非递归的会死锁，如果 mutex 为递归的，当 push_back() 可能会导致 vector 迭代器失效，程序偶尔 crash

死锁调试可以用 gdb 使用 thread apply all bt 指令

post 可以拆成 2 个函数

```cpp
void post(const Foo& f) {
    MutexLockGuard lock(mutex);
    postWithLockHold(f);
}

void postWithLockHold(const Foo& f) {
    foos.push_back(f)
}
```

1. 误用加锁版本死锁，可以通过调试解决
2. 误用不加锁版本，数据损坏了

```cpp
void postWithLockHold(const Foo& f) {
    assert(mutex.isLockedByThisThread());  //muduo::MutexLock 提供了这个成员函数
    foos.push_back(f)
}
```

windows 的 CRITICAL_SECTION 轻量级的，结合 spin lock。在多 cpu 系统上，如果不能立刻拿到锁，会先 spin 一小段时间，如果还不能拿到锁，才挂起当前线程。Linux 的 PTHREAD_MUTEX_ADAPTIVE_NP 与此类似

### 死锁

死锁的条件

| 条件名称                 | 核心定义                                                                 | 示例                                                                 | 破坏该条件的方案                                                                 | 破坏方案示例                                                                 |
|--------------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------|----------------------------------------------------------------------------------|------------------------------------------------------------------------------|
| 资源互斥（Mutual Exclusion） | 资源只能被一个进程/线程独占，其他请求者必须等待（不可同时使用）。         | 打印机同一时间只能被一个程序使用；Java中的`synchronized`锁是独占锁。   | 用“共享资源”替代“独占资源”（仅适用于可共享场景）                                | 将“独占打印机”改为“打印队列”（多进程共享队列，而非直接独占设备）。             |
| 持有并等待（Hold and Wait）  | 进程/线程已持有至少一个资源，同时又在等待其他进程/线程持有的资源。         | 线程A已获取“文件读锁”，又请求“文件写锁”（而写锁被线程B持有）。           | 要求进程/线程一次性获取所有所需资源，否则不持有任何资源                            | 线程启动前，先申请“锁A+锁B”，只有两者都获取成功才执行；若缺一个，则释放已申请资源并等待。 |
| 不可剥夺（No Preemption）    | 进程/线程持有的资源不能被强制剥夺，只能由持有者主动释放。                 | 线程A持有的锁，不能被系统强制收回，必须等A执行完`unlock()`才释放。        | 允许系统/其他进程强制剥夺已持有的资源（需资源支持“可剥夺”特性）                    | 数据库事务中，若事务A等待事务B的锁超时，系统可强制回滚事务A，释放其持有的锁。       |
| 循环等待（Circular Wait）    | 多个进程/线程形成环形等待链，每个节点都等待下一个节点的资源。             | 线程1等线程2的锁，线程2等线程3的锁，线程3等线程1的锁，形成闭环。         | 给所有资源编号，要求进程/线程按“从小到大”的固定顺序获取资源                        | 给锁A编号1、锁B编号2，所有线程必须先获取编号小的锁A，再获取编号大的锁B，避免循环。 |

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/test/SelfDeadLock.cc" "c++" "linenos=true" >}}

process 已经加锁，锁的作用域未整个函数，锁未释放前，调用函数 print 也加锁等待，持续等待无法退出，造成死锁现象。

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/test/MutualDeadLock.cc" "c++" "linenos=true" >}}

这个是线程 threadFunc 调用 ~Request 获取了 Request 的锁， 主线程调用 printAll 获取了 Inventory 实例的锁，~Request 在调用 remove 后才会释放锁，而 remove 又等待 Inventory 实例的锁释放来移除 Request 实例，两个线程间导致死锁。

## 条件变量

互斥锁是加锁原语，用来排他性的访问共享数据，它不是等待原语。使用 mutex 时，一般期望加锁不阻塞，能立刻拿到锁，尽快访问数据，尽快解锁，这样才不影响并发性和性能。

如果需要等待某个条件成立，则使用条件变量。条件变量是一个或多个线程等待某个布尔表达式为真，即等待线程的唤醒。条件变量的学名为管程（monitor）。Java Object 内置的 wait()、notify()、notifyAll() 是条件变量。这三个函数容易用错，一般建议用 java.util.concurrent 中的同步原语。

条件变量只有一种正确使用方式。对于 wait 端：

1. 必须与 mutex 一起使用，该布尔表达式的读写受锁的保护。
2. 在 mutex 已经上锁的情况下，才调用 wait()
3. 把判断布尔条件和 wait() 放到 while 循环中

```cpp
muduo::MutexLock mutex;
muduo::Condition cond(mutex);
std::deque<int> queue;

int dequeue() {
    MutexLockGuard lock(mutex);
    while (queue.empty) { //必须用循环；必须在判断之后再 wait() ; if 可能会 spurious wakeup 
        cond.wait(); //这一步会原子地 unlock mutex 并进入等待，不会与 enqueue 死锁， wait() 执行完毕时会自动重新加锁
    }
}
```

对于 singal/broadcast 端：

1. 不一定要在 mutex 已上锁地情况下调用 signal。（理论上）
2. 在 singal 之前一定要修改布尔表达式。
3. 修改布尔表达式通常要用 mutex 保护（至少用在 full memory barrier）。
4. 注意区分 singal 与 broadcast：“broadcast 通常用于表明状态变化，signal 通常用于表示资源可用。”

```cpp
void enqueue(int x) {
    MutexLockGuard lock(mutex);
    queue.push_back(x);
    cond.notify();  //可用移出临界区之外
}
```

一般使用类模板：

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/BlockingQueue.h" "c++" "linenos=true" >}}

倒计时（CountDownLatch）一种常见地同步手段，主要两个用途：

1. 主线程发起多个子线程，等待这些子线程各自完成一定地任务之后，主线程才继续执行。通常用于主线程等待多个子线程完成初始化。
2. 主线程发起多个子线程，子线程都等待主线程，主线程完成其他的一下任务之后，通知所有子线程开始执行。通常用于多个子线程等待主线程发起“起跑”的命令。

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/CountDownLatch.h" "c++" "linenos=true" >}}

## 不要用读写锁和信号量

- 正确性来说，可能修改代码读锁函数调用了修改状态的函数，导致共享数据被修改。
- 性能方面，读写锁不见得比 mutex 高效。
- read lock 可能可以提升为 write lock。
- read lock 可重入，write lock 不可重入，但为了防止 writer 饥饿， writer lock 通常会阻塞后来得 reader lock，因此 read locker 在重入得时候可能死锁。在追求低延迟读写得场合也不适合读写锁。对读写有极高得性能要求，可考虑 read-copy-update。

信号量：不是必备同步原语，条件变量加互斥锁完全可替代。同时信号量有自己得计数值，通常数据结构中也会有长度值，需要时刻保持一致，增加复杂度，控制并发度，可考虑 ThreadPool

### 信号量（Semaphore）与互斥锁（Mutex）特性对比表

| 特性                | 信号量（Semaphore）                          | 互斥锁（Mutex）                          |
|---------------------|----------------------------------------------|-----------------------------------------|
| 所有权              | 无（任何线程可获取/释放许可）                 | 有（仅持有线程可释放锁）                |
| 典型操作示例        | 线程A获取许可后，线程B可释放该许可（语法合法） | 线程A加锁后，线程B尝试解锁会触发错误（如死锁） |
| 核心用途            | 控制并发访问数量（如限制5个线程同时访问资源）  | 保证资源独占访问（如同一时间仅1个线程操作共享数据） |

## 封装 MutexLock 、MutexLockGuard 、Condition

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/Mutex.h" "c++" "linenos=true" >}}

以上代码达不到工业强度：

1. mutex 创建用PTHREAD_MUTEX_DEFAULT 类型，不是 PTHREAD_MUTEX_NORMAL 类型，严格说使用 mutexattr 指定锁类型
2. 没有检测返回值。assert 使用 release build 会被优化成空语句。goolge-glog 的 CHECK() 宏是个思路。

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/Condition.h" "c++" "linenos=true" >}}

像上面 CountDownLatch 代码，使用 mutex 和 condition 同时时，注意初始化顺序，先 mutex 后 condition

## 线程安全的 Singleton 实现

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/Singleton.h" "c++" "linenos=true" >}}

## sleep(3) 不是同步原语

生产代码中线程的等待分两种：一种是等待资源可用（要么等待在 select/poll/epoll_wait上，要么等待条件变量上）；一种是等待进入临界区（mutex 上）以便读取数据。后一种等待通常极短，否则程序的性能和伸缩性有问题。

## 归纳总结

- 线程的四项原则，尽量使用高层同步设施（线程池、队列、倒计时）；
- 使用普通的互斥锁和条件变量完成剩余的同步任务，使用 RAII 手法和 Scoped Locking。

## 借 shared_ptr 实现 copy-on-write

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/test/CopyOnWrite_test.cc" "c++" "linenos=true" >}}

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/test/RequestInventory_test.cc" "c++" "linenos=true" >}}

Request 析构的 race condition 解决 

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/test/RequestInventory_test2.cc" "c++" "linenos=true" >}}

### 普通 mutex 替换读写锁

背景线程读写，工作线程只读。

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/test/Customer.cc" "c++" "linenos=true" >}}

## Reference

http://queue.acm.org/detail.cfm?id=1454462

https://computing.llnl.gov/tutorials/pthreads

http://www.thinkingparallel.com/2007/02/19/please-dont-rely-on-memory-barriers-for-synchronization/

http://zaitcev.livejournal.com/144041.html

http://www.kernel.org/doc/Documentation/volatile-considered-harmful.txt

http://www.cs.wustl.edu/~schrnidt/PDF/locking-patterns.pdf  Douglas Schmidt 论文

http://llvm.org/devmtg/2011-11/#talk3

http://zaval.org/resources/library/butenhof1.html

http://www.akkadia.org/drepper/futex.pdf

http://msdn.microsoft.com/en-us/library/windows/desktop/ms682530(v=vs.85).aspx

http://blog.csdn.net/panaimin/article/details/5981766

http://www.nwcpp.org/Downloads/2007/Machine_Architecture_-_NWCPP.pdf

http://www.aristeia.com/TalkNotes/ACCU2011_CPUCaches.pdf

http://igoro.com/archive/gallery-of-processor-cache-effects/

http://simplygenius.net/Article/FalseSharing

http://blog.csdn.net/solstice/article/details/11432817
http://blog.csdn.net/solstice/article/details/5829421#comments

http://en.wikipedia.org/wiki/Spurious_wakeup

http://en.wikipedia.org/wiki/Read-copy-update

https://www.artima.com/shop/effective_cpp_in_an_embedded_environment

http://www.drdobbs.com/cpp/lock-free-code-a-false-sense-of-security/210600279

Intel Thread Ckecker  

Valgrind-Helgrind

http://valgrind.org/docs/manual/hg-manual.html/#hg-manual.data-races.algorithm

http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf

http://www.cs.wustl.edu/~schmidt/PDF/DC-Locking.pdf

http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html

http://www.javaworld.com/jw-02-2001/jw-0209-double.html

http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf

http://scottmeyers.blogspot.com/2012/04/information-on-c11-memory-model.html

《Ad Hoc Synchronization Considered Harmful》 http://www.usenix.org/events/osdi10/tech/full_papers/Xiong.pdf

http://pdos.csail.mit.edu/papers/linux:osdi10.pdf

http://preshing.com/20111118/locks-arent-slow-lock-contention-is

《Programming with POSIX Threads》

RWC

