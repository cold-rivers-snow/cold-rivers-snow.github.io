---
title: "02线程同步精要"
date: 2025-10-26T20:04:14+08:00
author: ["寒江雪"]

categories:
- muduo
- 多线程
- linux
- c++

description: "" # 文章描述，与搜索优化相关
summary: "muduo 文章阅读" # 文章简单描述，会展示在主页
draft: false # 是否为草稿
math: true # 启用/禁用KaTeX渲染。
comments: true
image:  # 文章图片
toc: true # 目录 默认值 .Site.Params.Article.toc， bool 类型，至少有一个标题才会显示
showToc: true # 显示目录
TocOpen: true # 自动展开目录
readingTime: true # 显示阅读时间
autonumbering: true # 目录自动编号
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
searchHidden: false # 该页面可以被搜索到
showbreadcrumbs: true #顶部显示当前路径
mermaid: true # 是否流程图渲染
style:  # 用于文章页面中出现的分类术语徽章的额外CSS样式。用于列表页面，目前仅支持background和color
    background: "white"
    color: "black"
license: 
    enabled: false
    default: Licensed under CC BY-NC-SA 4.0
cover:   # 封面的详细信息
    image: ""  # 封面图片
    caption: "" # 封面图片下方显示的文字说明或标题
    alt: "" # 封面图片提供替代文本
    relative: false # 所提供的图片路径是否为相对路径
---

并发编程有两种基本模型：

- message passing （消息传递）
- shared memory （共享内存）

分布式系统中，运行多台机器上的多个进程并发只有一种实用模型：message passing

线程同步的四项原则：

1. 首先尽量最低限度地共享对象，减少需要同步地场合。一个对象能不暴露给别地线程不要暴露；如果要暴露，优先考虑 immutable 对象，实在不行才暴露可修改地对象，并用同步措施来充分保护它。
2. 其次使用高级地并发编程构件。如 TaskQueue、Producer-Consumer Queue、CountDownLatch 等等。
3. 最后不得已必须使用同步原语时，只用非递归地互斥器和条件变量，慎用读写锁，不要用信号量。
4. 除了使用 atomic 整数之外，不自己编写 lock-free 代码，也不要用“内核级”同步原语。不凭空猜测“那种性能会更好”，比如 spin lock vs mutex.

## 互斥锁

原则：

- 使用 RAII 手法操作 mutex
- 只用不可重入锁
- 不手动 lock() unlock(),交给 RAII
- 不用跨进程地锁，进程间只用 TCP sockets。
- 必要时候可以考虑用 PTHREAD_MUTEX_ERRORCHECK 来排错。

mutex 分为递归和非递归两种，这是 POSIX 地叫法，另外名字是可重入和非可重入，这两种唯一地区别是同一个线程可以重复对 recursive mutex 加锁，但是不能重复对 non-recursive mutex 加锁。

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/test/NonRecursiveMutex_test.cc" "c++" "linenos=true" >}}

1. post() 和 traverse() 加锁都没问题
2. doit() 间接调用 post() 导致 mutex 非递归的会死锁，如果 mutex 为递归的，当 push_back() 可能会导致 vector 迭代器失效，程序偶尔 crash

死锁调试可以用 gdb 使用 thread apply all bt 指令

post 可以拆成 2 个函数

```cpp
void post(const Foo& f) {
    MutexLockGuard lock(mutex);
    postWithLockHold(f);
}

void postWithLockHold(const Foo& f) {
    foos.push_back(f)
}
```

1. 误用加锁版本死锁，可以通过调试解决
2. 误用不加锁版本，数据损坏了

```cpp
void postWithLockHold(const Foo& f) {
    assert(mutex.isLockedByThisThread());  //muduo::MutexLock 提供了这个成员函数
    foos.push_back(f)
}
```

windows 的 CRITICAL_SECTION 轻量级的，结合 spin lock。在多 cpu 系统上，如果不能立刻拿到锁，会先 spin 一小段时间，如果还不能拿到锁，才挂起当前线程。Linux 的 PTHREAD_MUTEX_ADAPTIVE_NP 与此类似

### 死锁

死锁的条件

| 条件名称                 | 核心定义                                                                 | 示例                                                                 | 破坏该条件的方案                                                                 | 破坏方案示例                                                                 |
|--------------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------|----------------------------------------------------------------------------------|------------------------------------------------------------------------------|
| 资源互斥（Mutual Exclusion） | 资源只能被一个进程/线程独占，其他请求者必须等待（不可同时使用）。         | 打印机同一时间只能被一个程序使用；Java中的`synchronized`锁是独占锁。   | 用“共享资源”替代“独占资源”（仅适用于可共享场景）                                | 将“独占打印机”改为“打印队列”（多进程共享队列，而非直接独占设备）。             |
| 持有并等待（Hold and Wait）  | 进程/线程已持有至少一个资源，同时又在等待其他进程/线程持有的资源。         | 线程A已获取“文件读锁”，又请求“文件写锁”（而写锁被线程B持有）。           | 要求进程/线程一次性获取所有所需资源，否则不持有任何资源                            | 线程启动前，先申请“锁A+锁B”，只有两者都获取成功才执行；若缺一个，则释放已申请资源并等待。 |
| 不可剥夺（No Preemption）    | 进程/线程持有的资源不能被强制剥夺，只能由持有者主动释放。                 | 线程A持有的锁，不能被系统强制收回，必须等A执行完`unlock()`才释放。        | 允许系统/其他进程强制剥夺已持有的资源（需资源支持“可剥夺”特性）                    | 数据库事务中，若事务A等待事务B的锁超时，系统可强制回滚事务A，释放其持有的锁。       |
| 循环等待（Circular Wait）    | 多个进程/线程形成环形等待链，每个节点都等待下一个节点的资源。             | 线程1等线程2的锁，线程2等线程3的锁，线程3等线程1的锁，形成闭环。         | 给所有资源编号，要求进程/线程按“从小到大”的固定顺序获取资源                        | 给锁A编号1、锁B编号2，所有线程必须先获取编号小的锁A，再获取编号大的锁B，避免循环。 |

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/test/SelfDeadLock.cc" "c++" "linenos=true" >}}

process 已经加锁，锁的作用域未整个函数，锁未释放前，调用函数 print 也加锁等待，持续等待无法退出，造成死锁现象。

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/test/MutualDeadLock.cc" "c++" "linenos=true" >}}

这个是线程 threadFunc 调用 ~Request 获取了 Request 的锁， 主线程调用 printAll 获取了 Inventory 实例的锁，~Request 在调用 remove 后才会释放锁，而 remove 又等待 Inventory 实例的锁释放来移除 Request 实例，两个线程间导致死锁。

## Reference

http://queue.acm.org/detail.cfm?id=1454462

https://computing.llnl.gov/tutorials/pthreads

http://www.thinkingparallel.com/2007/02/19/please-dont-rely-on-memory-barriers-for-synchronization/

http://zaitcev.livejournal.com/144041.html

http://www.kernel.org/doc/Documentation/volatile-considered-harmful.txt

http://www.cs.wustl.edu/~schrnidt/PDF/locking-patterns.pdf  Douglas Schmidt 论文

http://llvm.org/devmtg/2011-11/#talk3

http://zaval.org/resources/library/butenhof1.html

http://www.akkadia.org/drepper/futex.pdf

http://msdn.microsoft.com/en-us/library/windows/desktop/ms682530(v=vs.85).aspx

http://blog.csdn.net/panaimin/article/details/5981766

http://www.nwcpp.org/Downloads/2007/Machine_Architecture_-_NWCPP.pdf

http://www.aristeia.com/TalkNotes/ACCU2011_CPUCaches.pdf

http://igoro.com/archive/gallery-of-processor-cache-effects/

http://simplygenius.net/Article/FalseSharing

《Programming with POSIX Threads》

