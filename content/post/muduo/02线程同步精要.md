---
title: "02线程同步精要"
date: 2025-10-26T20:04:14+08:00
author: ["寒江雪"]

categories:
- muduo
- 多线程
- linux
- c++

description: "" # 文章描述，与搜索优化相关
summary: "muduo 文章阅读" # 文章简单描述，会展示在主页
draft: false # 是否为草稿
math: true # 启用/禁用KaTeX渲染。
comments: true
image:  # 文章图片
toc: true # 目录 默认值 .Site.Params.Article.toc， bool 类型，至少有一个标题才会显示
showToc: true # 显示目录
TocOpen: true # 自动展开目录
readingTime: true # 显示阅读时间
autonumbering: true # 目录自动编号
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
searchHidden: false # 该页面可以被搜索到
showbreadcrumbs: true #顶部显示当前路径
mermaid: true # 是否流程图渲染
style:  # 用于文章页面中出现的分类术语徽章的额外CSS样式。用于列表页面，目前仅支持background和color
    background: "white"
    color: "black"
license: 
    enabled: false
    default: Licensed under CC BY-NC-SA 4.0
cover:   # 封面的详细信息
    image: ""  # 封面图片
    caption: "" # 封面图片下方显示的文字说明或标题
    alt: "" # 封面图片提供替代文本
    relative: false # 所提供的图片路径是否为相对路径
---

并发编程有两种基本模型：

- message passing （消息传递）
- shared memory （共享内存）

分布式系统中，运行多台机器上的多个进程并发只有一种实用模型：message passing

线程同步的四项原则：

1. 首先尽量最低限度地共享对象，减少需要同步地场合。一个对象能不暴露给别地线程不要暴露；如果要暴露，优先考虑 immutable 对象，实在不行才暴露可修改地对象，并用同步措施来充分保护它。
2. 其次使用高级地并发编程构件。如 TaskQueue、Producer-Consumer Queue、CountDownLatch 等等。
3. 最后不得已必须使用同步原语时，只用非递归地互斥器和条件变量，慎用读写锁，不要用信号量。
4. 除了使用 atomic 整数之外，不自己编写 lock-free 代码，也不要用“内核级”同步原语。不凭空猜测“那种性能会更好”，比如 spin lock vs mutex.

## 互斥锁

原则：

- 使用 RAII 手法操作 mutex
- 只用不可重入锁
- 不手动 lock() unlock(),交给 RAII
- 不用跨进程地锁，进程间只用 TCP sockets。
- 必要时候可以考虑用 PTHREAD_MUTEX_ERRORCHECK 来排错。

mutex 分为递归和非递归两种，这是 POSIX 地叫法，另外名字是可重入和非可重入，这两种唯一地区别是同一个线程可以重复对 recursive mutex 加锁，但是不能重复对 non-recursive mutex 加锁。

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/test/NonRecursiveMutex_test.cc" "c++" "linenos=true" >}}

1. post() 和 traverse() 加锁都没问题
2. doit() 间接调用 post() 导致 mutex 非递归的会死锁，如果 mutex 为递归的，当 push_back() 可能会导致 vector 迭代器失效，程序偶尔 crash

死锁调试可以用 gdb 使用 thread apply all bt 指令

post 可以拆成 2 个函数

```cpp
void post(const Foo& f) {
    MutexLockGuard lock(mutex);
    postWithLockHold(f);
}

void postWithLockHold(const Foo& f) {
    foos.push_back(f)
}
```

1. 误用加锁版本死锁，可以通过调试解决
2. 误用不加锁版本，数据损坏了

```cpp
void postWithLockHold(const Foo& f) {
    assert(mutex.isLockedByThisThread());  //muduo::MutexLock 提供了这个成员函数
    foos.push_back(f)
}
```

windows 的 CRITICAL_SECTION 轻量级的，结合 spin lock。在多 cpu 系统上，如果不能立刻拿到锁，会先 spin 一小段时间，如果还不能拿到锁，才挂起当前线程。Linux 的 PTHREAD_MUTEX_ADAPTIVE_NP 与此类似

### 死锁

{{< remotecode "https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/thread/test/SelfDeadLock.cc" "c++" "linenos=true" >}}

## Reference

http://queue.acm.org/detail.cfm?id=1454462
https://computing.llnl.gov/tutorials/pthreads
http://www.thinkingparallel.com/2007/02/19/please-dont-rely-on-memory-barriers-for-synchronization/
http://zaitcev.livejournal.com/144041.html
http://www.kernel.org/doc/Documentation/volatile-considered-harmful.txt
http://www.cs.wustl.edu/~schrnidt/PDF/locking-patterns.pdf  Douglas Schmidt 论文
http://llvm.org/devmtg/2011-11/#talk3
http://zaval.org/resources/library/butenhof1.html
http://www.akkadia.org/drepper/futex.pdf
http://msdn.microsoft.com/en-us/library/windows/desktop/ms682530(v=vs.85).aspx

《Programming with POSIX Threads》

